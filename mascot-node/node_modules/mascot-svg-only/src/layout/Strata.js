import { Direction, ItemType, LayoutType, nodeId } from "mascot-svg-only/src/util/Constants";
import { normalizeAngle } from "mascot-svg-only/src/util/DataUtil";
import Layout from "mascot-svg-only/src/layout/Layout";

export default class StrataLayout extends Layout {

    constructor(args) {
		super(args);
		this.type = LayoutType.Strata;
		this._direction = args.direction;
		this._rootMark = args.rootMark;
		this._gap = "gap" in args ? args.gap : 0;
	}

    toJSON() {
		let json = {args: {}};
		json.type = this.type;
		json.args.direction = this._direction;
		json.args.rootMark = this._rootMark.id;
		json.args.gap = this._gap;
		return json;
	}

    clone() {

    }

    run() {
        if (this.group == undefined || !this.group.children || this.group.children.length === 0)
			return;
        
        let tree = this.group.firstChild.dataScope.dataTable.tree;
        if (!tree) return;

        let nodeId2mark = {};
		for (let item of this.group.children) {
			nodeId2mark[item.dataScope.getFieldValue(nodeId)] = item;
		}

        if (this._rootMark.type === ItemType.Rect) {
            this._layoutRects(tree.getRoot(), tree, nodeId2mark);
        } else if (this._rootMark.type === ItemType.Circle) {
            this._layoutArcs(tree.getRoot(), tree, nodeId2mark);
        }
    }

    _layoutArcs(node, tree, node2mark) {
		let childrenNodes = tree.getChildren(node);
		if (childrenNodes.length === 0) return;
		let parentMark = node2mark[node[nodeId]];
		let startAngle = parentMark.type == ItemType.Arc || parentMark.type == ItemType.Pie ? parentMark.startAngle : 90;
		for (let i = 0; i < childrenNodes.length; i++) {
			let cn = childrenNodes[i],
				mark = node2mark[cn[nodeId]];
			if (mark.type === ItemType.Arc) {
                let temp = normalizeAngle(startAngle + mark.angle);
                // console.log(mark.dataScope.getFieldValue("event_attribute"), mark.startAngle, mark.endAngle, mark.angle);
				
				mark.adjustAngle(startAngle, temp);
				startAngle = temp; 
			}
			this._layoutArcs(cn, tree, node2mark);
		}
        //console.log("-------------");
	}

    _layoutRects(node, tree, node2mark) {
        let childrenNodes = tree.getChildren(node);
		if (childrenNodes.length === 0) return;
		let parentMark = node2mark[node[nodeId]];
        let x, y;
        switch (this._direction) {
            case Direction.Down:
            default:
                x = parentMark.left;
                y = parentMark.bottom;
                break;
        }
		for (let i = 0; i < childrenNodes.length; i++) {
			let cn = childrenNodes[i],
				mark = node2mark[cn[nodeId]];
			
            mark._doTranslate(x - mark.left , y - mark.top);
            x += mark.width; 
            this._layoutRects(cn, tree, node2mark);
		}
    }
}
