// import { dagStratify, decrossOpt, sugiyama } from "d3-dag";
import { LayoutType, nodeId } from "mascot-svg-only/src/util/Constants";
import Layout from "mascot-svg-only/src/layout/Layout";
import * as dagre from "dagre";

export default class SugiyamaLayout extends Layout {

    constructor(args) {
        super(args);
        this.type = LayoutType.Sugiyama;
        this._width = "width" in args ? args["width"] : 500;
        this._height = "height" in args ? args["height"] : 300;
        this._top = "top" in args ? args["top"] : 0;
        this._left = "left" in args ? args["left"] : 0;
        this._edgeSep = "edgeSep" in args? args["edgeSep"] : 50;
    }

    toJSON() {
        let json = {args: {}};
		json.type = this.type;
		return json;
    }

    run() {
        let graph = this.group.children[0].dataScope._dt.graph;
        if (!graph) return;
        
        var g = new dagre.graphlib.Graph();
        g.setGraph({edgesep: this._edgeSep});
        g.setDefaultEdgeLabel(function() { return {}; });

        //in case the node ids in the input graph file are integers
        let nodeIdHash = new Map();
        for (let n of this.group.children) {
            let id = n.dataScope.getFieldValue(nodeId);
            nodeIdHash.set(id, id + "");
            g.setNode(id, {label: n.text ? n.text : "", width: n.bounds.width, height: n.bounds.height});
        }
        for (let l of graph.links) {
            g.setEdge(l.source, l.target);
        }
        dagre.layout(g);

        const nid2pos = {};
        let t = Math.min(...g.nodes().map(d => g.node(d).y)), l = Math.min(...g.nodes().map(d => g.node(d).x));
        let dx = this._left - l, dy = this._top - t;
        for (const id of g.nodes()) {
            nid2pos[id] = {x: g.node(id).x + dx, y: g.node(id).y + dy};
        }

        for (let node of this.group.children) {
            let nid = node.dataScope.getFieldValue(nodeId);
            node.x = nid2pos[nodeIdHash.get(nid)].x;
            node.y = nid2pos[nodeIdHash.get(nid)].y;
        }
        this.group._updateBounds();
        this.group.getScene()._updateAncestorBounds(this.group);
    }
}