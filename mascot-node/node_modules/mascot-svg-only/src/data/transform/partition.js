import { nodeId } from "../../util/Constants";
import Network from "../Network";

function merge(grouping, subgraphs) {
    let newGrouping = [grouping[0]], newSG = [subgraphs[0]];
    for (let i = 1; i < subgraphs.length; i++) {
        let canMerge = false, sg1 = subgraphs[i];
        for (let j = 0; j < newSG.length; j++) {
            let sg2 = newSG[j];
            let set = new Set(sg1);
            sg2.forEach(d => set.add(d));
            if (set.size < sg1.length + sg2.length) {
                newSG[j] = [...set];
                newGrouping[j] = newGrouping[j].concat(grouping[i])
                canMerge = true;
                break;
            }
        }
        if (!canMerge) {
            newSG.push(sg1);
            newGrouping.push(grouping[i]);
        }
    }
    return {grouping: newGrouping, subgraphs: newSG};
}

export default function partition(graph) {
    let nodes = graph.nodes, links = graph.links;
    let grouping = links.map((d, i) => [i]), subgraphs = links.map((d) => [d.source, d.target]);
    let newGrouping = merge(grouping, subgraphs);
    while (newGrouping.grouping.length != grouping.length) {
        grouping = newGrouping.grouping;
        subgraphs = newGrouping.subgraphs;
        newGrouping = merge(grouping, subgraphs);
    }

    let result = [];
    for (let [i, g] of newGrouping.grouping.entries()) {
        let data = {"nodes": [], "links": []};
        data.links = g.map(d => links[d]);
        const nids = newGrouping.subgraphs[i];
        data.nodes = nodes.filter( d => nids.indexOf(d[nodeId]) >= 0 );
        result.push(new Network(data));
    }
    return result;
}