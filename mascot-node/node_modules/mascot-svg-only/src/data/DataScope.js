import {Aggregator, atlas_rowId} from "../util/Constants";
import * as d3 from 'd3';


export default class DataScope {

	constructor(datatable) {
		this._field2value = {}; 
		this._dt = datatable;
		this._tuples = this._dt.data;
	}

	toJSON() {
		let json = {};
		json.dt = this._dt.id;
		json.f2v = Object.assign({}, this._field2value);
		json.tuples = this._tuples.map(d => parseInt(d[atlas_rowId].substring(1)));
		return json;
	}

	isFullTable() {
		return Object.keys(this._field2value).length === 0;
	}

	isEmpty() {
		return this._tuples.length == 0;
	}

	get numTuples() {
		return this._tuples.length;
	}

	get fields() {
		return Object.keys(this._field2value);
	}

	get dataTable() {
		return this._dt;
	}

	get filters() {
		return this._field2value;
	}

	merge(ds) {
		let r = new DataScope(this._dt);
		for (let field in ds._field2value) {
			r = r.cross(field, ds._field2value[field]);
		}
		for (let field in this._field2value) {
			r = r.cross(field, this._field2value[field]);
		}
		return r;
	}

	cross(field, value) {
		let ds = this.clone();
		ds._field2value[field] = value;
		ds._updateTuples(field, value);
		return ds;
	}

	clone() {
		let ds = new DataScope(this._dt);
		ds._field2value = Object.assign({}, this._field2value);
		ds._tuples = this._tuples.map(d => d);
		return ds;
	}

	getFieldValue(field) {
		let values = this._tuples.map(d => d[field]);
		values = [...new Set(values)];
		if (values.length > 1){
			//throw new Error(Errors.MULTIPLE_VALUES_PER_FIELD);
			//TODO: how to handle this?
		} 
		return values[0];
	}

	getUniqueFieldValues(field) {
		let values = this._tuples.map(d => d[field]);
		return [...new Set(values)];
	}

	hasField(field) {
		return (field in this._field2value);
	}

	getFieldType(field) {
		return this._dt.getFieldType(field);
	}

	aggregateNumericalField(field, aggregator) {
		let values = this._tuples.map(d => d[field]);
		switch (aggregator) {
			case Aggregator.Max:
				return Math.max(...values);
			case Aggregator.Min:
				return Math.min(...values);
			case Aggregator.Avg:
			case Aggregator.Mean:
				return d3.mean(values);
			case Aggregator.Median:
				return d3.median(values);
			case Aggregator.Count:
				return values.length;
			case Aggregator.Percentile25:
				return d3.quantile(values, 0.25);
			case Aggregator.Percentile75:
				return d3.quantile(values, 0.75);
			case Aggregator.Sum:
			default:
				return d3.sum(values);
		}
	}

	_updateTuples(field, value) {
		this._tuples = this._tuples.filter(d => d[field] == value);
	}

	get tuples() {
		return this._tuples;
	}
}