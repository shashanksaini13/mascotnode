import { ItemType } from "../../util/Constants";
import { getEncodingKey, getTopLevelCollection, getTopLevelGroup, ItemCounter } from "../../util/ItemUtil";
import Path from "../mark/Path";
import Group from "../composite/Group";
import CirclePath from "../mark/CirclePath";

export default class Gridlines extends Group {

    constructor(encoding, item, args) {
        super();
        this.type = ItemType.Gridlines;
        this.id = this.type + ItemCounter[this.type]++;

        this.encoding = encoding;
        this.channel = this.encoding.channel;
        this._item = item;

        this._strokeColor = ("strokeColor" in args) ? args["strokeColor"] : "#ddd";
        this._strokeWidth = ("strokeWidth" in args) ? args["strokeWidth"] : 1;
        
        if (this.channel == "radialDistance"){
            if("angle" in args){
                this._rotate = [-args["angle"], this.encoding.x, this.encoding.y];
            }
        }
    }

    toJSON(){
        // let json = {args: {}};
        let json = super.toJSON();
		json.type = this.type;
		json.id = this.id;
        if (!("args" in json))
            json.args = {};
        json.args.item = this._item.id;
        json.args.strokeColor = this._strokeColor;
        json.args.strokeWidth = this._strokeWidth;
        json.args.values = this._values;
        if (this.encoding.scale.type === "time") {
            json.args.isDate = true;
        }
        json.channel = this.encoding.channel;
        json.field = this.encoding.field;
        if (this._rotate)
            json.args.angle = this._rotate[0];
        return json;
    }

    get values() {
        return this._values;
    }

    set values(values) {
        this._values = values;
        this.updateLines();
        this.updateLinePositions();
    }

    get strokeColor() {
        return this._strokeColor;
    }

    set strokeColor(c) {
        this._strokeColor = c;
        for (let p of this.children)
            p.strokeColor = c;
    }

    get strokeWidth() {
        return this._strokeWidth;
    }

    set strokeWidth(w) {
        this._strokeWidth = w;
        for (let p of this.children)
            p.strokeWidth = w;
    }

    matches(item) {
        let k = getEncodingKey(item).split("_")[0],
            encodings = this.encoding.scale.encodings;
        for (let enc of encodings) {
            let classId = getEncodingKey(enc.anyItem).split("_")[0];
            if (classId === k)
                return true;
        }
        return false;
    }

    updateLinePositions() {
        let container = getTopLevelCollection(this._item) ? getTopLevelCollection(this._item) : getTopLevelGroup(this._item);
        if (this.channel == "x" || this.channel == "width") {
            let bounds = container.bounds,
                range = this.encoding.getScaleRange(this._item);
            for (let [i, l] of this.children.entries()) {
                let x = range[0] + this.encoding.scale.map(this._values[i]) - this.encoding.scale.range[0];
                l._setVertices([[x, bounds.top], [x, bounds.bottom]]);
            }
        } else if (this.channel == "y" || this.channel == "height") {
            let bounds = container.bounds,
            range = this.encoding.getScaleRange(this._item);
            if (this.encoding.flip) {
                for (let [i, l] of this.children.entries()) {
                    let y = range[1] - this.encoding.scale.map(this._values[i]) + this.encoding.scale.range[0];
                    l._setVertices([[bounds.left, y], [bounds.right, y]]);
                }
            } else {
                for (let [i, l] of this.children.entries()) {
                    let y = range[0] - this.encoding.scale.map(this._values[i]) + this.encoding.scale.range[0];
                    l._setVertices([[bounds.left, y], [bounds.right, y]]);
                }
            }
        } else if (this.channel == "radialDistance") {
            for (let [i, c] of this.children.entries()) {
                c.x = this._item.parent.x;
                c.y = this._item.parent.y;
                c.radius = this.encoding.scale.map(this._values[i]);
            }
        }
        for (let c of this.children)
            c._updateBounds();
        this._updateBounds();
    }

    updateLines() {
        this.children = [];
        if (this.channel == "x" || this.channel == "y" || this.channel == "width" || this.channel == "height") {
            for (let i = 0; i < this._values.length; i++) {
                let t = new Path ({"strokeColor": this._strokeColor, "fillColor": "none", "strokeWidth": this._strokeWidth});
                t.type = ItemType.Line;
                t.id = this.id + "line" + i;
                this.addChild(t);
            }
        } else if (this.channel == "radialDistance") {
            for (let i = 0; i < this._values.length; i++) {
                let t = new CirclePath({"strokeColor": this._strokeColor, "fillColor": "none", "strokeWidth": this._strokeWidth});
                t.type = ItemType.Circle;
                t.id = this.id + "line" + i;
                this.addChild(t);
            }
        }
    }

}