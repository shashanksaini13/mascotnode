// Based on item.Item.js, as part of Paper.js - The Swiss Army Knife of Vector Graphics Scripting.
// http://paperjs.org/
// Copyright (c) 2011 - 2019, Juerg Lehni & Jonathan Puckey
// http://scratchdisk.com/ & https://puckey.studio/
//
// Distributed under the MIT license. See LICENSE file for detail
//
// All rights reserved.

import LinearGradient from "mascot-svg-only/src/basic/Gradient";
import {Style2SVG, ItemType} from "mascot-svg-only/src/util/Constants";
import { CanvasProvider } from "mascot-svg-only/src/util/ItemUtil";

export default class Mark {

	constructor(args) {
		this._dataScope = undefined;
		this._id = undefined;

		this.attrs = {};
		this.styles = {};
		this.staticProperties = {};

		if (args !== undefined) {
			for (let s in Style2SVG) {
				if (s in args) {
					this.styles[s] = args[s];
				}
			}
		}
	}

	get id() {
		return this._id;
	}

	set id(id) {
		if (this.getScene()){
			delete this.getScene()._itemMap[this._id];
			this._id = id;
			this.getScene()._itemMap[id] = this;
		} else {
			this._id = id;
		}
	}

	//TODO: implement winding contribution, see paper.js PathItem.Boolean.js
	contains(px, py) {
		if (!this._bounds)
			return false;
		if (!this._bounds.contains(px, py))
			return false;
		switch (this.type) {
			case ItemType.Rect:
			case ItemType.PointText:
				return true;
			case ItemType.Circle: {
				let dist = Math.sqrt(Math.pow(px - this.x, 2) + Math.pow(py - this.y, 2));
				return dist <= this.radius + this.strokeWidth;
			}
			case ItemType.Path: {
				let ctx = CanvasProvider.getContext(),
					p = new Path2D(this.getSVGPathData());
				ctx.lineWidth = Math.max(this.strokeWidth, 2.5);
				ctx.stroke(p);
				if (this.closed) {
					return ctx.isPointInPath(p, px, py);
				} else {
					return ctx.isPointInStroke(p, px, py);
				}
			}
			case ItemType.Line: {
				let ctx = CanvasProvider.getContext(),
					p = new Path2D(this.getSVGPathData());
				ctx.lineWidth = Math.max(this.strokeWidth, 2.5);
				ctx.stroke(p);
				return ctx.isPointInStroke(p, px, py);
			}
			default: {
				let ctx = CanvasProvider.getContext(),
					p = new Path2D(this.getSVGPathData());
				return ctx.isPointInPath(p, px, py);
			}
		}
	}

	toJSON() {
		let json = {};
		json.type = this.type;
		json.id = this.id;
		if (this.classId)
			json.classId = this.classId;
		if (this._dataScope)
			json.dataScope = this._dataScope.toJSON();
		json.args = {};
		for (let s in this.attrs) {
			json.args[s] = this.attrs[s];
		}

		for (let s in this.styles) {
			if (s.indexOf("Color") > 0 && this.styles[s] instanceof LinearGradient) {
				json.args[s] = this.styles[s].toJSON();
			} else {
				json.args[s] = this.styles[s];
			}
		}
		return json;
	}

	getScene() {
		let p = this;
		while (p) {
			if (p.type == ItemType.Scene)
				return p;
			else
				p = p.parent;
		}
	}

	set dataScope(ds) {
		this._dataScope = ds;
	}

	get dataScope() {
		return this._dataScope;
	}

	duplicate() {
		let scene = this.getScene();
		let m = scene.mark(this.type);
		this.copyPropertiesTo(m);
		m.classId = this.classId;
		if (this._dataScope) {
			m._dataScope = this._dataScope.clone();
		}
		return m;
	}

	// eslint-disable-next-line no-unused-vars
	_doTranslate(dx, dy){
		//child classes have their own implementations
	}

	set visibility(v) {
		this.styles["visibility"] = v;
	}

	get visibility() {
		if (!this.styles["visibility"])
			return "visible";
		return this.styles["visibility"];
	}

	get opacity() {
		if (!("opacity" in this.styles))
			return 1;
		return this.styles["opacity"];
	}

	set opacity(c) {
		this.styles["opacity"] = c;
	}
}