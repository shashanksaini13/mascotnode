import Path from "./Path";
import {ItemType} from "../../util/Constants";
import Rectangle from "../../basic/Rectangle";
import Point from "../../basic/Point";
import { degree2radian } from "../../util/ItemUtil";

export default class ArcPath extends Path {
	
	constructor(args) {
		super(args);
		
		this._type = ItemType.Arc;
		this.closed = true;
		this._x = "x" in args ? args.x : 0;
		this._y = "y" in args ? args.y : 0;
		this._innerRadius = "innerRadius" in args ? args.innerRadius : 100;
        this._outerRadius = "outerRadius" in args ? args.outerRadius : 200;
        this._startAngle = "startAngle" in args ? args.startAngle : 0;
        this._endAngle = "endAngle" in args ? args.endAngle : 90;
        this._sr = degree2radian(this._startAngle);
        this._er = degree2radian(this._endAngle);

        let isx = this._x + this._innerRadius * Math.cos(this._sr), isy = this._y - this._innerRadius * Math.sin(this._sr),
            iex = this._x + this._innerRadius * Math.cos(this._er), iey = this._y - this._innerRadius * Math.sin(this._er),
            osx = this._x + this._outerRadius * Math.cos(this._sr), osy = this._y - this._outerRadius * Math.sin(this._sr),
            oex = this._x + this._outerRadius * Math.cos(this._er), oey = this._y - this._outerRadius * Math.sin(this._er);
        this._setVertices([[isx, isy], [osx, osy], [oex, oey], [iex, iey]]);
	}

    get type() {
        return this._innerRadius === 0 ? ItemType.Pie : ItemType.Arc;
    }

    set type(t) {
        this._type = t;
    }

	get innerRadius() {
		return this._innerRadius;
	}

    set innerRadius(r) {
		this._innerRadius = r;
        this.vertices[0].x = this._x + this._innerRadius * Math.cos(this._sr);
        this.vertices[0].y = this._y - this._innerRadius * Math.sin(this._sr);
        this.vertices[3].x = this._x + this._innerRadius * Math.cos(this._er);
        this.vertices[3].y = this._y - this._innerRadius * Math.sin(this._er);
        this._updateBounds();
	}

    get outerRadius() {
		return this._outerRadius;
	}

    get thickness() {
        return this._outerRadius - this._innerRadius;
    }

    set outerRadius(r) {
		this._outerRadius = r;
        this.vertices[1].x = this._x + this._outerRadius * Math.cos(this._sr);
        this.vertices[1].y = this._y - this._outerRadius * Math.sin(this._sr);
        this.vertices[2].x = this._x + this._outerRadius * Math.cos(this._er);
        this.vertices[2].y = this._y - this._outerRadius * Math.sin(this._er);
		this._updateBounds();
	}

	get x() {
		return this._x;
	}

	get y() {
		return this._y;
	}

	get center() {
		return new Point(this._x, this._y);
	}

	set x(v) {
		this._x = v;
        this.vertices[0].x = this._x + this._innerRadius * Math.cos(this._sr);
        this.vertices[1].x = this._x + this._outerRadius * Math.cos(this._sr);
        this.vertices[2].x = this._x + this._outerRadius * Math.cos(this._er);
        this.vertices[3].x = this._x + this._innerRadius * Math.cos(this._er);
		this._updateBounds();
	}

	set y(v) {
		this._y = v;
        this.vertices[0].y = this._y - this._innerRadius * Math.sin(this._sr);
        this.vertices[1].y = this._y - this._outerRadius * Math.sin(this._sr);
        this.vertices[2].y = this._y - this._outerRadius * Math.sin(this._er);
        this.vertices[3].y = this._y - this._innerRadius * Math.sin(this._er);
		this._updateBounds();
	}

	get startAngle() {
        return this._startAngle;
    }

    get endAngle() {
        return this._endAngle;
    }

    get angle() {
        if (this._endAngle < this._startAngle) {
            return this._endAngle + 360 - this._startAngle;
        } else {
            return this._endAngle - this._startAngle;
        }
    }

    //if the sweep angle of this arc contains the arc argument
    sweepOver(arc) {
        let as = this.startAngle, ae = this.endAngle;
        if (ae < as)    ae += 360;
        let bs = arc.startAngle, be = arc.endAngle;
        if (be < bs)    be += 360;
        return bs >= as && bs <= ae && be >= as && be <= ae;
    }

	_doTranslate(dx, dy) {
		this._x += dx;
		this._y += dy;
        this.vertices[0].x = this._x + this._innerRadius * Math.cos(this._sr);
        this.vertices[0].y = this._y - this._innerRadius * Math.sin(this._sr);
        this.vertices[1].x = this._x + this._outerRadius * Math.cos(this._sr);
        this.vertices[1].y = this._y - this._outerRadius * Math.sin(this._sr);
        this.vertices[2].x = this._x + this._outerRadius * Math.cos(this._er);
        this.vertices[2].y = this._y - this._outerRadius * Math.sin(this._er);
        this.vertices[3].x = this._x + this._innerRadius * Math.cos(this._er);
        this.vertices[3].y = this._y - this._innerRadius * Math.sin(this._er);
		this._updateBounds();
	}

	_updateBounds() {		
		this._bounds = new Rectangle(this._x - this._outerRadius, this._y - this._outerRadius, this._outerRadius * 2, this._outerRadius * 2);
	}

	copyPropertiesTo(target) {
		super.copyPropertiesTo(target);
		target._x = this._x;
		target._y = this._y;
		target._innerRadius = this._innerRadius;
        target._outerRadius = this._outerRadius;
        target._startAngle = this._startAngle;
        target._endAngle = this._endAngle;
        target._sr = this._sr;
        target._er = this._er;
	}

    getSVGPathData() {
        let angle = this._endAngle < this._startAngle? this._endAngle + 360 - this._startAngle : this._endAngle - this._startAngle, 
            largeArc = angle > 180 ? 1 : 0;
        let cmds = [
            "M " + this.vertices[0].x + ", " + this.vertices[0].y,
            "L " + this.vertices[1].x + ", " + this.vertices[1].y,
            "A " + [this._outerRadius, this._outerRadius, angle, largeArc, 0, this.vertices[2].x, this.vertices[2].y].join(" "),
            "L " + this.vertices[3].x + ", " + this.vertices[3].y,
            "A " + [this._innerRadius, this._innerRadius, angle, largeArc, 1, this.vertices[0].x, this.vertices[0].y].join(" ")
        ];
        return cmds.join(" ");
    }

    adjustAngle(startAngle, endAngle) {
        this._startAngle = startAngle;
        this._endAngle = endAngle;
        this._sr = degree2radian(this._startAngle);
        this._er = degree2radian(this._endAngle);

        this.vertices[0].x = this._x + this._innerRadius * Math.cos(this._sr);
        this.vertices[0].y = this._y - this._innerRadius * Math.sin(this._sr);
        this.vertices[1].x = this._x + this._outerRadius * Math.cos(this._sr);
        this.vertices[1].y = this._y - this._outerRadius * Math.sin(this._sr);
        this.vertices[2].x = this._x + this._outerRadius * Math.cos(this._er);
        this.vertices[2].y = this._y - this._outerRadius * Math.sin(this._er);
        this.vertices[3].x = this._x + this._innerRadius * Math.cos(this._er);
        this.vertices[3].y = this._y - this._innerRadius * Math.sin(this._er);
    }
}