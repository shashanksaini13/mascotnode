import {getParents, getClosestLayout, getCellBoundsInLayout, sameClass, getPeers, getCellIndexInLayout} from "../util/ItemUtil";
import {DataType, ItemType, LayoutType} from "../util/Constants";
import Scale from "../core/Scale";

export function bindToPosition(encoding){

	encoding._query = function() {
		this.data = [];
		
		let field = this.field, items = this.items;
		let dataScopes = ((this.anyItem.type == "vertex" || this.anyItem.type == "segment") && !this.anyItem.dataScope) ? 
							items.map(d => d.parent.dataScope) : items.map(d => d.dataScope);

		switch (this.datatable.getFieldType(field)) {
			case DataType.Boolean:
				break;

			case DataType.Date:
				this.data = dataScopes.map(d => d.getFieldValue(field));
				break;

			case DataType.String:
				try {
					this.data = dataScopes.map(d => d.getFieldValue(field));
				} catch (error) {
					throw new Error("Cannot bind " + this.channel + " to " + field + " : " + error);
				}
				break;

			default: //integer or number
				this.data = dataScopes.map(d => d.aggregateNumericalField(field, this.aggregator));
				break;
		}
	}

	encoding._map = function() {
		let channel = this.channel, fieldType = this.datatable.getFieldType(this.field);

		//to be used for determining the range of scale 
		//TODO: need to update cellBounds dynamically for _map() and _apply()
		let extent;
		let layout = getClosestLayout(this.anyItem);
		if (layout && layout.type == LayoutType.Grid) {
			let cellBounds = layout.cellBounds;
			extent = channel == "x" ? cellBounds[0].width : cellBounds[0].height;
		} else if (this.anyItem.type === "vertex" && this.anyItem.parent.type === ItemType.Area) {
			extent = channel == "x" ? this.anyItem.parent.bounds.width : this.anyItem.parent.bounds.height;
		} else {
			let pos = this.items.map(d => d[channel]);
			extent = Math.max(...pos) - Math.min(...pos);
			if (extent < 100) extent = 100;
			else if (extent > 500) extent = 500;
		}

		let min, max, domain, range;
		switch (fieldType) {
			case DataType.Boolean:
				break;

			case DataType.Date:
				min = Math.min(...this.data); 
				max = Math.max(...this.data);
				domain = [min, max];
				if (this.scale) {
					// let domainValues = domain.concat(this.scale.domain);
					let domainValues = this.data;
					for (let enc of this.scale.encodings) {
						domainValues = domainValues.concat(enc.data);
					}
					domain = [Math.min(...domainValues), Math.max(...domainValues)];
					//extent = Math.abs(this.scale.map(domain[0]) - this.scale.map(domain[1]));
					range = this.scale.range;
				} else {
					this.scale = new Scale("time");
					this.scale.isFlipped = this._flipScale;
					range = [0, extent];
					this.scale._baseItem = this.anyItem;
				}
				break;

			case DataType.String:
				domain = Array.from(new Set(this.data));
				range = [0, extent];
				if (this.scale) {
					let od = this.scale.domain;
					//the following lines preserve the order of values in existing domain
					for (let d of domain) {
						if (od.indexOf(d) < 0)
							od.push(d);
					}
					domain = od;
					//domain = Array.from(new Set(domain.concat(this.scale.domain)));
					range = this.scale.range;
				} else {
					this.scale = new Scale("point");
					this.scale.isFlipped = this._flipScale;
					range = [0, extent];
					this.scale._baseItem = this.anyItem;
				}
				break;

			default: //integer or number
				min = Math.min(...this.data); 
				max = Math.max(...this.data);
				domain = [min, max];
				
				if (this.scale) {
					//where zero is included depends on the existing scale
					let domainValues = this.data;
					for (let enc of this.scale.encodings) {
						domainValues = domainValues.concat(enc.data);
					}
					// let domainValues = domain.concat(this.scale._scale.domain());
					domain = [Math.min(...domainValues), Math.max(...domainValues)]; 

					range = this.scale.range;
				} else {
					this.scale = new Scale(this.scaleType);
					this.scale.isFlipped = this._flipScale;
					this.scale.includeZero = this._includeZero;
					range = [0, extent];
					//remember the item that was used to first create this scale,
					//so that when the scale is reused later, we can refer to the base item
					//to get absoluate positions
					this.scale._baseItem = this.anyItem;
				}
				if (domain[0] == domain[1])
					domain[1] = domain[0] * 1.1;
				break;
		}

		this.scale._scale.domain(domain);
		this.scale._setRange(range);

		//TODO: need to adjust according to scale type
		this.scale._addEncoding(this);
	}

	encoding._apply = function() {
		let items = [], channel = this.channel;
		//if the scale is shared across multiple encodings, need to find the offset based on all items using this scale
		//use case: box plot, where lines, rect segments and line vertices share the same scale
		for (let enc of this.scale.encodings)
			items = items.concat(enc.items);
		if (channel == "x") {
			//let layout = getClosestLayout(this.anyItem, "grid");
			//let layout = getTopLevelCollection(this.anyItem) ? getTopLevelCollection(this.anyItem).layout : getClosestLayout(this.anyItem);
			let layout = getClosestLayout(this.anyItem, "grid"), baseLayout = this.scale._baseItem ? getClosestLayout(this.scale._baseItem, "grid"): undefined;
			if (this.scale._baseItem && !sameClass(this.anyItem, this.scale._baseItem) && layout && baseLayout && layout.numRows === baseLayout.numRows && layout.numCols === baseLayout.numCols) {
				let tx = baseLayout.group.bounds.left - layout.group.bounds.left,
					ty = 0;
				layout.group.getScene().translate(layout.group, tx, ty);
				layout._colGap = baseLayout.colGap;
				let cellIndices = this.items.map(d => getCellIndexInLayout(d)),
					baseCellBounds = baseLayout.cellBounds;
				for (let i = 0; i < this.items.length; i++) {
					let itm = this.items[i];
					let dx = baseCellBounds[cellIndices[i]].left + this.scale.map(this.data[i]) - itm[channel],
						dy = 0;
					itm._doTranslate(dx, dy);
					if (itm.type == "vertex" || itm.type == "segment")
						itm.parent._updateBounds();
				}
				this.anyItem.parent.getScene()._updateAncestorBounds(this.anyItem, this.items);
			} else if (layout && layout.type == LayoutType.Grid){
				//do not use scale.offset, use cell bounds
				for (let i = 0; i < this.items.length; i++) {
					let itm = this.items[i], itmCb = getCellBoundsInLayout(itm);
					let dx = itmCb.left + this.scale.map(this.data[i]) - itm[channel],
						dy = 0;
					itm._doTranslate(dx, dy);
					if (itm.type == "vertex" || itm.type == "segment")
						itm.parent._updateBounds();
				}
			} else if (this.anyItem.type === "vertex" && this.anyItem.parent.type === ItemType.Area) {
				//this is to make sure that the encoding of vertex position is within the bounds of an area mark
				let marks = getParents(this.items);
				if (this.scale.offset === undefined)
					this.scale.offset = Math.min(...marks.map(d => d.bounds.left));
				for (let i = 0; i < this.items.length; i++) {
					let peer = this.items[i], parent = peer.parent;
					let dx = parent.bounds.left + this.scale.map(this.data[i]) - peer[channel],
						dy = 0;
					peer._doTranslate(dx, dy);
					peer.parent._updateBounds();
				}
			}  else if (this.anyItem.type == "vertex" || this.anyItem.type == "segment") {
				//TODO: right now using the leftmost mark peer as the baseline, which will not work for cases like bullet chart
				//need to check if marks are part of a glyph, and use the leftmose glyph peer.
				let marks = getParents(this.items);
				if (this.scale.offset === undefined)
					this.scale.offset = Math.min(...marks.map(d => d.bounds.left));
				for (let i = 0; i < this.items.length; i++) {
					let peer = this.items[i];
					let dx = this.scale.offset + this.scale.map(this.data[i]) - peer[channel],
						dy = 0;
					peer._doTranslate(dx, dy);
					peer.parent._updateBounds();
				}
			} else {
				if (this.scale.offset === undefined)
					this.scale.offset = Math.min(...items.map(d => d[channel]));
				if (this.items[0].type === ItemType.PointText)
					this.items.forEach(d => d.horzAnchor = "center");
				for (let i = 0; i < this.items.length; i++) {
					let peer = this.items[i];
					let dx = this.scale.offset + this.scale.map(this.data[i]) - peer[channel],
						dy = 0;
					peer._doTranslate(dx, dy);
				}
			}
			
		} else {//channel y
			//let layout = getTopLevelCollection(this.anyItem) ? getTopLevelCollection(this.anyItem).layout : getClosestLayout(this.anyItem);
			let layout = getClosestLayout(this.anyItem, "grid"), baseLayout = this.scale._baseItem ? getClosestLayout(this.scale._baseItem, "grid"): undefined;
			if (this.scale._baseItem && !sameClass(this.anyItem, this.scale._baseItem) && layout && baseLayout && layout.numRows === baseLayout.numRows && layout.numCols === baseLayout.numCols) {
			//if (this.scale._baseItem && !sameClass(this.anyItem, this.scale._baseItem) && baseLayout && baseLayout.numRows === 1) {
				//let peers = getPeers(this.scale._baseItem, this.scale._baseItem.parent.getScene());
				let tx = 0,
					ty = baseLayout.group.bounds.top - layout.group.bounds.top;
				layout.group.getScene().translate(layout.group, tx, ty);
				layout._rowGap = baseLayout.rowGap;
				let cellIndices = this.items.map(d => getCellIndexInLayout(d)),
					baseCellBounds = baseLayout.cellBounds;
				for (let i = 0; i < this.items.length; i++) {
					let itm = this.items[i];
					let dx = 0,
						dy = baseCellBounds[cellIndices[i]].bottom - this.scale.map(this.data[i]) - itm[channel];
					itm._doTranslate(dx, dy);
					if (itm.type == "vertex" || itm.type == "segment")
						itm.parent._updateBounds();
				}
				this.anyItem.parent.getScene()._updateAncestorBounds(this.anyItem, this.items);
			} else if (layout && layout.type == LayoutType.Grid){
				let cellBounds = this.items.map(d => getCellBoundsInLayout(d));
				for (let i = 0; i < this.items.length; i++) {
					let itm = this.items[i];
					let dx = 0,
						dy = cellBounds[i].bottom - this.scale.map(this.data[i]) - itm[channel];
					itm._doTranslate(dx, dy);
					if (itm.type == "vertex" || itm.type == "segment")
						itm.parent._updateBounds();
				}
			} else if (this.anyItem.type === "vertex" && this.anyItem.parent.type === ItemType.Area) {
				if (this.scale.offset === undefined)
					this.scale.offset = Math.min(...this.items.map(d => d.y));
				for (let i = 0; i < this.items.length; i++) {
					let peer = this.items[i], parent = peer.parent;
					let dx = 0,
						dy = parent.bounds.top + this.scale.rangeExtent - this.scale.map(this.data[i]) - peer[channel];
					peer._doTranslate(dx, dy);
					peer.parent._updateBounds();
				}
			}  else if (this.anyItem.type == "vertex" || this.anyItem.type == "segment") {
				if (this.scale.offset === undefined)
					this.scale.offset = Math.min(...this.items.map(d => d.y));
				for (let i = 0; i < this.items.length; i++) {
					let peer = this.items[i];
					let dx = 0,
						dy = this.scale.offset + this.scale.rangeExtent - this.scale.map(this.data[i]) - peer[channel];
					peer._doTranslate(dx, dy);
					peer.parent._updateBounds();
				}
			} else {
				if (this.scale.offset === undefined)
					this.scale.offset = Math.min(...items.map(d => d.bounds.y));
				if (this.items[0].type === ItemType.PointText)
					this.items.forEach(d => d.vertAnchor = "middle");
				for (let i = 0; i < this.items.length; i++) {
					let peer = this.items[i];
					let dx = 0,
						dy = this.scale.offset + this.scale.rangeExtent - this.scale.map(this.data[i]) - peer.refBounds[channel];
					peer._doTranslate(dx, dy);
				}
			}
		}
	}

	encoding.run();
	if (encoding.rangeExtent)
		encoding.scale.rangeExtent = encoding.rangeExtent;
	return encoding;
}