import Scale from "../core/Scale";
import {DataType, ItemType} from "../util/Constants";
import { normalizeAngle } from "../util/DataUtil";

export function bindToAngle(encoding){

	encoding._query = function() {
		this.data = [];
		this.id2data = {};

		let field = this.field, items = this.items;

		switch (this.datatable.getFieldType(field)) {
			case DataType.Boolean:
				break;

			case DataType.Date:
				this.data = items.map(d => d.dataScope.getFieldValue(field));
				break;

			case DataType.String:
				break;

			default: //integer or number
				this.data = items.map(d => d.dataScope.aggregateNumericalField(field, this.aggregator));
				break;
		}
		for (let i = 0; i < this.data.length; i++) {
			this.id2data[items[i].id] = this.data[i];
		}
	}

	encoding._map = function() {
		if (this.scale) {
		} else {
			this.scale = new Scale("linear");
			this.scale.domain = this.datatable.tree ? [0, Math.max(...this.data)] : [0, this.data.reduce((a, d) => a + d, 0)];
			this.scale._setRange([0, 360]);
			this.scale._addEncoding(this);
		}
	}

	encoding._apply = function() {
		let peer;
		for (let i = 0; i < this.items.length; i++) {
			peer = this.items[i];
			if (peer.type === ItemType.Arc || peer.type === ItemType.Pie) {
				peer.adjustAngle(peer.startAngle, normalizeAngle(peer.startAngle + this.scale.map(this.data[i])));
			}
		}
		this.scene._relayoutAncestors(this.anyItem, this.items);
	}

	encoding.run();
	return encoding;
}