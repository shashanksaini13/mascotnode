import Scale from "../core/Scale";
import {categoricalColorSchemes, DataType, divergingColorSchemes, sequentialColorSchemes} from "../util/Constants";

export function bindToColor(encoding){

	encoding._query = function() {
		this.data = [];
		
		let field = this.field, items = this.items;
		let dataScopes = ((this.anyItem.type == "vertex" || this.anyItem.type == "segment") && !this.anyItem.dataScope) ? 
							items.map(d => d.parent.dataScope) : items.map(d => d.dataScope);

		switch (this.datatable.getFieldType(field)) {
			case DataType.Boolean:
				this.data = [true, false];
				break;

			case DataType.Date:
				this.data = dataScopes.map(d => d.getFieldValue(field));
				break;

			case DataType.String:
				try {
					this.data = dataScopes.map(d => d.getFieldValue(field));
				} catch (error) {
					throw new Error("Cannot bind " + this.channel + " to " + field + " : " + error);
				}
				break;

			default: //integer or number
				this.data = dataScopes.map(d => d.aggregateNumericalField(field, this.aggregator));
				break;
		}
	}

	encoding._map = function() {
		switch (this.datatable.getFieldType(this.field)) {
			case DataType.Boolean:
				if (!this.scale) {
					this.scale = new Scale("ordinalColor");
					this.scale.domain = this.data;
					if (this._mapping) {
						let range = this.scale.domain.map(d => d in this._mapping ? this._mapping[d] : "black");
						this.scale._scale.range(range);
					}
				} 
				break;
			case DataType.String:
				if (this.scale) {
					this.scale.domain = Array.from(new Set(this.scale.domain.concat(this.data)));
				} else {
					let args = {scheme: "schemeCategory10"};
					if (this._scheme) {
						if (categoricalColorSchemes.indexOf(this._scheme) >= 0) {
							args.scheme = this._scheme;
						} else if (divergingColorSchemes.indexOf(this._scheme) >= 0 || sequentialColorSchemes.indexOf(this._scheme) >= 0) {
							args.scheme = this._scheme;
							args.size = this.data.length;
						}
					}
					this.scale = new Scale("ordinalColor", args);
					this.scale.domain = this.data;
					if (this._mapping) {
						let range = this.scale.domain.map(d => d in this._mapping ? this._mapping[d] : "black");
						this.scale._scale.range(range);
					}
				}
				break;

			default: //number or date
				if (this.scale) {
					if (!this._mapping) {
						let values = this.scale.domain.concat(this.data);
						this.scale.domain = [Math.min(...values), Math.max(...values)];
					}
				} else {
					if (this._mapping) {
						this.scale = new Scale("linear", this._mapping);
					} else {
						let min = Math.min(...this.data), max = Math.max(...this.data), 
							abs = Math.max(Math.abs(min), Math.abs(max)), scheme;
						if (min < 0 && max > 0) {
							scheme = "interpolatePuOr";
							min = -abs;
							max = abs;
							this.scale = new Scale("divergingColor", this._scheme ? this._scheme: scheme);
						} else {
							scheme = "interpolateTurbo";
							this.scale = new Scale("sequentialColor", this._scheme ? this._scheme: scheme);
						}
						this.scale.domain = [min, max];
					}
				}
				break;
		}
		this.scale._addEncoding(this);
	}

	encoding._apply = function() {
		for (let i = 0; i < this.items.length; i++) {
			let peer = this.items[i], value = this.scale.map(this.data[i]);
			if (peer.type == "vertex" || peer.type == "segment")
				peer[this.channel] = value;
			else
				peer.styles[this.channel] = value;
			if (peer.vertices && this.channel == "strokeColor") {
				peer.vertices.forEach(d => d.fillColor = value);
			}
		}
	}

	encoding.run();
	return encoding;
}