import StrataLayout from "../layout/Strata";
import { Direction, Errors, ItemType } from "../util/Constants";
import { normalizeAngle } from "../util/DataUtil";
import { getPeers } from "../util/ItemUtil";

export function stratifyItem(scene, compnt, direction, size, tree) {
    switch (compnt.type) {
		// case ItemType.Line:
		// 	return _doLineDivide(scene, compnt, f, datatable);
		case ItemType.Circle:
			return _doCircleStratify(scene, compnt, direction, size, tree);
		case ItemType.Rect:
			return _doRectStratify(scene, compnt, direction, size, tree);
		// case ItemType.Pie:
		// 	return _doPieDivide(scene, compnt, orientation, f, datatable);
	}
}

function _doCircleStratify(scene, compnt, dir, sz, tree) {
	let toReturn, direction = dir ? dir : Direction.Outward, size = sz ? sz : 50;
	if (direction !== Direction.Inward && direction !== Direction.Outward) {
		throw Errors.UNKNOWN_DIRECTION + " " + direction;
	}
	let peers = getPeers(compnt, scene);
	let collClassId;
	peers.forEach(p => {
		let coll = scene.collection();
		coll.dataScope = undefined;
		if (collClassId == undefined)
			collClassId = coll.id;
		coll.classId = collClassId;
		let parent = p.parent;
		_addArcStrata(p, compnt.id, direction, size, tree, tree.getRoot(), coll, scene, true);
		coll.layout = new StrataLayout({direction: direction, rootMark: p});
		parent.addChild(coll);
		
		if (p === compnt)
			toReturn = coll;
	});
	return toReturn;
}

function _addArcStrata(compnt, classId, direction, size, tree, node, coll, scene, isRoot) {
	if (isRoot) {
		compnt.dataScope = tree.getNodeDataScope(node);
		// console.log(mark.dataScope);
		compnt.classId = classId;
		coll.addChild(compnt);
	}
	let children = tree.getChildren(node);
	if (children.length === 0) return;
	let start = compnt.type === ItemType.Circle || compnt.type === ItemType.Ring ? 90 : compnt.startAngle,
		extent = compnt.type === ItemType.Circle || compnt.type === ItemType.Ring ? 360 : compnt.angle,
		angle = extent/children.length;
	for (let i = 0; i < children.length; i++) {
		let ir = compnt.type === ItemType.Circle ? compnt.radius : compnt.outerRadius;
		let mark;
		if (angle === 360) {
			mark = scene.mark("ring", {
				innerRadius: ir,
				outerRadius: ir + size,
				x: compnt.x,
				y: compnt.y,
				strokeColor: compnt.strokeColor,
				fillColor: compnt.fillColor,
				strokeWidth: compnt.strokeWidth,
				opacity: compnt.opacity
			});
		} else {
			mark = scene.mark("arc", {
				innerRadius: ir,
				outerRadius: ir + size,
				x: compnt.x,
				y: compnt.y,
				startAngle: normalizeAngle(start + angle * i),
				endAngle: normalizeAngle(start + angle * (i+1)),
				strokeColor: compnt.strokeColor,
				fillColor: compnt.fillColor,
				strokeWidth: compnt.strokeWidth,
				opacity: compnt.opacity
			});
		}
		mark.dataScope = tree.getNodeDataScope(children[i]);
		// console.log(mark.dataScope);
		mark.classId = classId;
		coll.addChild(mark);
		_addArcStrata(mark, classId, direction, size, tree, children[i], coll, scene);
	}
}

function _doRectStratify(scene, compnt, dir, sz, tree) {
	let toReturn, direction = dir ? dir : Direction.Down, size = sz ? sz : 50;
	if ([Direction.Up, Direction.Down, Direction.Left, Direction.Right].indexOf(direction) < 0) {
		throw Errors.UNKNOWN_DIRECTION + " " + direction;
	}
	let peers = getPeers(compnt, scene);
	let collClassId;
	peers.forEach(p => {
		let coll = scene.collection();
		coll.dataScope = undefined;
		if (collClassId == undefined)
			collClassId = coll.id;
		coll.classId = collClassId;
		let parent = p.parent;
		_addRectStrata(p, compnt.id, direction, size, tree, tree.getRoot(), coll, scene, true);
		coll.layout = new StrataLayout({direction: direction, rootMark: p});
		parent.addChild(coll);
		
		if (p === compnt)
			toReturn = coll;
	});
	return toReturn;
}

function _addRectStrata(compnt, classId, direction, size, tree, node, coll, scene, isRoot) {
	if (isRoot) {
		compnt.dataScope = tree.getNodeDataScope(node);
		compnt.classId = classId;
		coll.addChild(compnt);
	}
	let children = tree.getChildren(node);
	if (children.length === 0) return;
	let x, y, width, height;
	switch (direction) {
		case Direction.Up:
		case Direction.Down:
		case Direction.Left:
		case Direction.Right:
		default:
			x = compnt.left;
			y = compnt.bottom;
			width = compnt.width/children.length;
			break;
	}

	// let start = compnt.type === ItemType.Circle || compnt.type === ItemType.Ring ? 90 : compnt.startAngle,
	// 	extent = compnt.type === ItemType.Circle || compnt.type === ItemType.Ring ? 360 : compnt.angle,
	// 	angle = extent/children.length;
	for (let i = 0; i < children.length; i++) {
		let mark = scene.mark("rect", {
			left: x,
			top: y,
			width: width,
			height: size,
			strokeColor: compnt.strokeColor,
			fillColor: compnt.fillColor,
			strokeWidth: compnt.strokeWidth,
			opacity: compnt.opacity
		});
		x += width;
		mark.dataScope = tree.getNodeDataScope(children[i]);
		mark.classId = classId;
		coll.addChild(mark);
		_addRectStrata(mark, classId, direction, size, tree, children[i], coll, scene);
	}
}