import {Errors, DataType, nodeId, atlas_rowId} from "../util/Constants";
import DataScope from "../data/DataScope";
import { isMark, itemIsRepeatable } from "../util/ItemUtil";

export function repeatable(compnt) {
	if (Array.isArray(compnt)) {
		if (compnt.length === 1) {
			return itemIsRepeatable(compnt[0]);
		} else {
			for (let c of compnt) {
				if (!isMark(c) || c.dataScope)
					return false;
			}
		}
		return true;
	} else {
		return itemIsRepeatable(compnt);
	}
	// else if ((isMark(compnt) || compnt.type == ItemType.Glyph) && !compnt.dataScope) {
	// 	return true;
	// } else if (compnt.type == ItemType.Collection) {
	// 	return itemIsRepeatable(compnt);
	// }
	//return false;
}

export function repeatItem(scene, compnt, field, datatable, callback) {
	let f = callback ? datatable.transformField(field, callback) : field;
	let type = datatable.getFieldType(f);

	if (type != DataType.String && type != DataType.Date && type != DataType.Integer) {
		throw new Error(Errors.REPEAT_BY_NONCAT + ": " + f + " is " + type);
	}

	if (!repeatable(compnt)) {
		throw new Error(Errors.COMPNT_NON_REPEATABLE);
	}

	return _doRepeat(scene, compnt, f, datatable);
}

function _doRepeat(scene, compnt, field, datatable) {
	let ds = datatable.getFieldSummary(field).unique.map(d => compnt.dataScope ? compnt.dataScope.cross(field, d) : new DataScope(datatable).cross(field, d));
	ds = ds.filter(d => !d.isEmpty());
	let coll = scene.collection();
	coll.dataScope = compnt.dataScope ? compnt.dataScope.clone() :  new DataScope(datatable);

	//scene.addChild(coll);
	
	//do not initialize classId here, initialize in scene.mark/glyph/new Collection()
	// compnt.classId = compnt.id;
	coll.addChild(compnt);

	for (let i = 1; i < ds.length; i++) {
		let c = compnt.duplicate();
		coll.addChild(c);
	}

	coll.children.forEach((d, i) => d.dataScope = ds[i]);
	//TODO: turn the folllwing into getter and setter
	// if (!scene.cellAlign.hasOwnProperty(compnt.classId)) {
	// 	scene.cellAlign[compnt.classId] = {x: Alignment.Left, y: Alignment.Bottom};
	// }
	scene._reapplySizeBindings(compnt);
	return coll;
}

export function repeatNodeLink(scene, node, link, data) {
	let nodeDS = data.nodeTable.getFieldSummary(nodeId).unique.map(d => node.dataScope ? node.dataScope.cross(nodeId, d) : new DataScope(data.nodeTable).cross(nodeId, d));
	let linkColl = scene.collection(), nodeColl = scene.collection(), id2node = {};
	nodeColl.dataScope = node.dataScope ? node.dataScope.clone() :  new DataScope(data.nodeTable);
	
	//do not initialize classId here, initialize in scene.mark/glyph/new Collection()
	// compnt.classId = compnt.id;
	nodeColl.addChild(node);
	for (let i = 1; i < nodeDS.length; i++) {
		let c = node.duplicate();
		nodeColl.addChild(c);
	}

	nodeColl.children.forEach((d, i) => {
		d.dataScope = nodeDS[i];
		id2node[d.dataScope.getFieldValue(nodeId)] = d;
	});

	let linkDS = data.linkTable.getFieldSummary(atlas_rowId).unique.map(d => link.dataScope ? link.dataScope.cross(atlas_rowId, d) : new DataScope(data.linkTable).cross(atlas_rowId, d));
	linkColl.dataScope = link.dataScope ? link.dataScope.clone() : new DataScope(data.linkTable);

	linkColl.addChild(link);
	for (let i = 1; i < linkDS.length; i++) {
		let c = link.duplicate();
		linkColl.addChild(c);
	}

	linkColl.children.forEach((d, i) => d.dataScope = linkDS[i]);
	let s = data.type === "tree" ? "parent" : "source", t = data.type === "tree" ? "child" : "target";
	for (let l of linkColl.children) {
		let sid = l.dataScope.getFieldValue(s),
			tid = l.dataScope.getFieldValue(t);
		l.source = id2node[sid];
		l.target = id2node[tid];
		l._updateBounds();
	}
	
	return [nodeColl, linkColl];
}