import {Errors, DataType, ItemType, Orientation, Alignment} from "../util/Constants";
import DataScope from "../data/DataScope";
import {getPeers, polar2Cartesian} from "../util/ItemUtil";
import Vertex from "../item/Vertex";

export function densifiable(compnt) {
	if ([ItemType.Line, ItemType.Circle, ItemType.Rect, ItemType.Area].indexOf(compnt.type) < 0) {
		return false;
	} 
	if (!compnt.dataScope) {
		return true;
	} else {
		let peers = getPeers(compnt, compnt.getScene());
		for (let p of peers) {
			if (p.dataScope.numTuples > 1)
				return true;
		}
		return false;
	}
}

export function densifyItem(scene, compnt, orientation, field, datatable, callback, startAngle, direction) {	
	let f = callback ? datatable.transformField(field, callback) : field;
	let type = datatable.getFieldType(f);

	if (type != DataType.String && type != DataType.Date && type != DataType.Number) {
		throw new Error(Errors.DENSIFY_BY_NONCAT + ": " + f + " is " + type);
	}

	if (!densifiable(compnt, f, scene)) {
		throw new Error(Errors.COMPNT_NON_DENSIFIABLE);
	}

	switch (compnt.type) {
		case ItemType.Line:
			return _doLineDensify(scene, compnt, f, datatable);
		case ItemType.Circle:
			return _doCircleDensify(scene, compnt, f, datatable, startAngle, direction);
		case ItemType.Rect:
		case ItemType.Area:
			return _doAreaDensify(scene, compnt, orientation, f, datatable);
	}
	
}

function _doLineDensify(scene, compnt, field, datatable) {
	let peers = getPeers(compnt, scene);

	let toReturn;
	for (let p of peers) {
		let lineDS = p.dataScope ? p.dataScope : new DataScope(datatable);
		let ds = datatable.getFieldSummary(field).unique.map(d => lineDS.cross(field, d));
		ds = ds.filter(d => !d.isEmpty());
		if (ds.length === 1) {
			ds.push(ds[0].clone());
		}

		let args = Object.assign({}, p.styles);
		for (let vs of Vertex.styles){
			if (p[vs])
				args[vs] = p[vs];
		}

		//compute vertices
		let x1 = p.vertices[0].x,
			y1 = p.vertices[0].y,
			x2 = p.vertices[1].x,
			y2 = p.vertices[1].y;

		let vertices = [], wd = x2 - x1, ht = y2 - y1;
		for (let i = 0; i < ds.length; i++){
			vertices.push([x1 + i * wd / (ds.length - 1), y1 + i * ht /(ds.length - 1)]);
		}
		args.vertices = vertices;
		let polyLine = scene.mark("path", args);
		polyLine.classId = compnt.id;
		polyLine.dataScope = lineDS;

		let parent = p.parent;
		parent.addChild(polyLine);
		parent.removeChild(p);

		for (let [i, v] of polyLine.vertices.entries()){
			if (v.dataScope)
				v.dataScope = v.dataScope.merge(ds[i]);
			else
				v.dataScope = ds[i];
		}

		if (p == compnt)
			toReturn = polyLine;
	}
	return toReturn;
}

function _doAreaDensify(scene, compnt, orientation, field, datatable) {
	let peers = getPeers(compnt, scene);
	let toReturn;
	
	for (let p of peers) {
		// How to handle missing elements across different partitions in area mark?
		let ft = datatable.getFieldType(field);
		let areaDS = p.dataScope ? p.dataScope : new DataScope(datatable);
		let ds = datatable.getFieldSummary(field).unique.map(d => areaDS.cross(field, d));
		ds = ft == DataType.Number? ds : ds.filter(d => !d.isEmpty());
		if (ds.length === 1) {
			ds.push(ds[0].clone());
		}
		
		if (ft == DataType.Number || ft == DataType.Date) {
			// sorting ds
			ds.sort((a, b) => (a._field2value[field] > b._field2value[field]) ? 1 : -1)
		}
		let args = Object.assign({}, p.styles);
		//compute vertices
		let x1 = p.vertices[0].x,
			y1 = p.vertices[0].y,
			x2 = p.vertices[p.vertices.length - 2].x,
			y2 = p.vertices[p.vertices.length - 2].y;

		let vertices = [], wd = x2 - x1, ht = y2 - y1;
		for(let j = 0; j < ds.length; j++) {
			vertices.push(orientation == Orientation.Vertical ? [x2, y1 + (ds.length-1-j) * ht /(ds.length - 1)] : [x1 + j * wd / (ds.length - 1), y1]);
		}
		for(let j = 0; j < ds.length; j++) {
			vertices.push(orientation == Orientation.Vertical ? [x1, y1 + j * ht /(ds.length - 1)] : [x1 + (ds.length-1-j) * wd / (ds.length - 1), y2]);
		}
		args.vertices = vertices;
		let NewArea = scene.mark("area", args);
		// Very Important: keep new areas' classID consistent
		NewArea.classId = p.type == "area"? p.classId : "area" + p.classId.substring(9);
		NewArea.dataScope = areaDS;
		NewArea.orientation = orientation;
		NewArea.baseline = orientation === Orientation.Horizontal ? Alignment.Bottom : Alignment.Left;

		let parent = p.parent;
		parent.addChild(NewArea);
		parent.removeChild(p);

		for (let [i, v] of NewArea.vertices.entries()){
			// two boundary lines are encoded the same; possible to modify later according to the data encoding
			if (i>=ds.length) {
				v.dataScope = areaDS.merge(ds[ds.length*2-1-i]);
			}
			else {
				v.dataScope = areaDS.merge(ds[i]);
			}
		}
		if (p == compnt) {
			toReturn = NewArea;
			// targetArea = NewArea;
		}
	}
	return toReturn;
}

function _doCircleDensify(scene, compnt, field, datatable, startAngle, direction) {
	let toReturn;
	let peers = getPeers(compnt, scene);
	peers.forEach(p => {
		let circDS = p.dataScope ? p.dataScope : new DataScope(datatable);
		let ds = datatable.getFieldSummary(field).unique.map(d => circDS.cross(field, d));
		ds = ds.filter(d => !d.isEmpty()); 
		let numVertices = ds.length;
		if (numVertices < 3)
			throw Error(Errors.INSUFFICIENT_DATA_SCOPES);
		let k = 360/numVertices, vertices = [], angle = [];
		let dirSign = direction == "clockwise" ? -1 : 1;
		for (let i = 0; i < ds.length; i++){
			let a = startAngle + dirSign * i * k;
			angle[i] = a;
			let coords = polar2Cartesian(p.x, p.y, p.radius, angle[i]);
			vertices.push(coords);
		}
		let polygon = scene.mark("polygon", {x: p.x, y: p.y, radius: p.radius, vertices:vertices});
		polygon.dataScope = circDS;
		polygon.styles = Object.assign({}, p.styles);
		for (let vs of Vertex.styles){
			if (p[vs])
				polygon[vs] = p[vs];
		}

		let parent = p.parent;
		parent.addChild(polygon);
		parent.removeChild(p);

		for (let [i, v] of polygon.vertices.entries()){
			v.polarAngle = angle[i];
			if (v.dataScope)
				v.dataScope = v.dataScope.merge(ds[i]);
			else
				v.dataScope = ds[i];
		}

		if (p == compnt)
			toReturn = polygon;
	});
	return toReturn;
}