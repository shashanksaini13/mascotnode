import LayoutAxis from "../item/refs/LayoutAxis";
import { LayoutType, Orientation } from "../util/Constants";
import { getEncodingKey, getPeers, isGuide } from "../util/ItemUtil";

const SceneValidator = {

    itemTranslated: function(item, dx, dy) {
        let scene = item.getScene();
        if (!isGuide(item))
			scene._reapplyConstraints(item);

        let axes = scene.getRelatedAxes(item);
		axes.forEach(a => {
			if (a.encoding && a.encoding.scale.offset !== undefined)
				a.encoding.scale.offset += a.channel === "x" || a.channel === "width" ? dx : dy;
            if (dy !== 0 && (a.channel === "x" || a.channel === "width") && a._posArg !== undefined) {
                a._posArg = a._posArg + dy;
            }
            if (dx !== 0 && (a.channel === "y" || a.channel === "height") && a._posArg !== undefined) {
                a._posArg = a._posArg + dx;
            }
			a.reposition();
		});
		let gl = scene.getRelatedGridlines(item);
		gl.forEach(l => l.updateLinePositions());
    },

    layoutChanged: function(item, peers, props) {
        let scene = item.getScene();
        scene._relayoutAncestors(item, peers);

        let items = [item], c = item.firstChild
        while (c) {
            items.push(c);
            c = c.firstChild;
        }
        for (let i of items)
			i.getScene()._reapplyConstraints(i);

        let reGenerateAxes = false;
        for (let p of props) {
            if (["numRows", "numCols", "layout", "childrenOrder"].indexOf(p) >= 0) {
                reGenerateAxes = true;
                break;
            }
        }

        //if grid layout changes to a single column or row, or stack layout's orientation changes, update axis channel
        let updateChannel = false, channel;
        if (item.layout) {
            if (item.layout.type === LayoutType.Grid && (item.layout.numRows === 1 || item.layout.numCols === 1)) {
                updateChannel = true;
                channel = item.layout.numRows === 1 ? "x" : "y";
            } else if (item.layout.type === LayoutType.Stack && props.indexOf("orientation") >= 0) {
                updateChannel = true;
                channel = item.layout.orientation === Orientation.Horizontal ? "x" : "y";
            }
        }
        if (updateChannel) {
            let axes = scene.getRelatedAxes(item).filter(d => d instanceof LayoutAxis && d._item.parent.classId === item.classId);
            for (let a of axes) {
                scene.removeItem(a);
                let args = a.toJSON().args;
                delete args["orientation"];
                args.item = item.firstChild;
                scene.axis(channel, a.field, args);
            }
        }
        
        if (reGenerateAxes) {
            scene.reCreateRelatedAxes(item);
        } else {
            let axes = scene.getRelatedAxes(item);
            axes.forEach(a => a.reposition());
        }

        let gl = scene.getRelatedGridlines(item);
		gl.forEach(l => l.updateLinePositions());
    },

    scaleDomainSet: function(scale) {
        for (let enc of scale.encodings) {
			enc._map();
			enc._apply();
		}

        for (let enc of scale.encodings) {
			enc.scene._updateAncestorBounds(enc.item, enc.items);
		}
		//reapply constraints
		let items = scale.encodings.map( d => d.anyItem), classId2item = {};
		for (let item of items) {
			if (item.type === "vertex" || item.type === "segment")
				classId2item[item.parent.classId] = item.parent;
			else
				classId2item[item.classId] = item;
		}
		for (let i of Object.values(classId2item))
			i.getScene()._reapplyConstraints(i);

        for (let enc of scale.encodings) {
            let item = enc.anyItem;
            let axes = enc.scene.getRelatedAxes(item);
            for (let a of axes) {
                if (a.encoding && a.encoding.scale === scale) {
                    a.tickValues = enc._inferTickValues(enc);
                    a.labelValues = enc._inferTickValues(enc);
                    a._positionPath();
                    if (a._showTitle)
                        a._positionTitle();
                    if (a._channel === "radialDistance" && a._rotate){
                        a._rotate = [a._rotate[0], a._item.parent.x, a._item.parent.y];
                    }
                    a._updateBounds();
                }
            }
            let gl = enc.scene.getRelatedGridlines(item);
            gl.forEach(l => l.updateLinePositions());
        }
    },

    scaleRangeSet: function(scale) {
        for (let enc of scale.encodings) {
			//enc._map();
			enc._apply();
		}

        for (let enc of scale.encodings) {
			enc.scene._relayoutAncestors(enc.item, enc.items);
		}
		//reapply constraints
		let items = scale.encodings.map( d => d.anyItem), classId2item = {};
		for (let item of items) {
			if (item.type === "vertex" || item.type === "segment")
				classId2item[item.parent.classId] = item.parent;
			else
				classId2item[item.classId] = item;
		}
		for (let i of Object.values(classId2item))
			i.getScene()._reapplyConstraints(i);

        for (let enc of scale.encodings) {
            let item = enc.anyItem;
            let axes = enc.scene.getRelatedAxes(item);
            axes.forEach(a => a.reposition());
            let gl = enc.scene.getRelatedGridlines(item);
            gl.forEach(l => l.updateLinePositions());
        }
    },
    
    itemResized: function(item, peers) {
        let scene = item.getScene();
        scene._relayoutAncestors(item, peers);
		scene._reapplyConstraints(item);
        let axes = scene.getRelatedAxes(item);
        axes.forEach(a => a.reposition());
        let gl = scene.getRelatedGridlines(item);
        gl.forEach(l => l.updateLinePositions());
    },

    markDivided: function(path, collection) {
        //update axis item argument
        let scene = collection.getScene();
        let axes = scene.getRelatedAxes(path);
        for (let a of axes) {
            if (a._item.classId === path.classId) {
                a._item = collection;
                a._items = getPeers(collection, scene);
            }
        }

        //update encoding item
        let e = scene.encodings[getEncodingKey(path)];
        if (e) {
            scene.encodings[getEncodingKey(collection)] = {};
            for (let channel of ["x", "y"]) {
                const enc = e[channel];
                if (!enc)
                    continue;
                enc.anyItem = collection;
                enc.items = getPeers(collection, scene);
                scene.encodings[getEncodingKey(collection)][channel] = enc;
                delete scene.encodings[getEncodingKey(path)][channel];
            }
            if (Object.keys(e).length === 0)
                delete scene.encodings[getEncodingKey(path)];
        }
        //TODO: update constraints
    },

    markDensified: function(item, newItem) {
        let scene = newItem.getScene();
        let e = scene.encodings[getEncodingKey(item)];
        if (e) {
            scene.encodings[getEncodingKey(newItem)] = {};
            for (let channel of ["x", "y"]) {
                const enc = e[channel];
                if (!enc)
                    continue;
                enc.anyItem = newItem;
                enc.items = getPeers(newItem, scene);
                scene.encodings[getEncodingKey(newItem)][channel] = enc;
                delete scene.encodings[getEncodingKey(item)][channel];
            }
            if (Object.keys(e) === 0)
                delete scene.encodings[getEncodingKey(item)];
        }

        let axes = scene.getRelatedAxes(item);
        for (let a of axes) {
            if (a._item.classId === item.classId) {
                a._item = newItem;
                a._items = getPeers(newItem, scene);
            }
        }
        //TODO: update constraints
    },

    areaRebased: function(item) {
        let scene = item.getScene();
        let encodings = scene.encodings[getEncodingKey(item)];
        for (let channel in encodings) {
            encodings[channel]._apply();
        }
        let axes = scene.getRelatedAxes(item);
        axes.forEach(a => a.reposition());
        let gl = scene.getRelatedGridlines(item);
        gl.forEach(l => l.updateLinePositions());
    }
};

export default SceneValidator;