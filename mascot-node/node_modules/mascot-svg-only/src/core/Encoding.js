import {getPeers, getClosestLayout, getTopLevelLayout, CheckAreaOrien, getCellBoundsInGridLayout, getEncodingKey, getTopLevelCollection, isMark} from "../util/ItemUtil";
import {Alignment, DataType, LayoutType} from "../util/Constants";
import {ItemType, Orientation} from "../util/Constants";
import * as d3 from 'd3'; 

export default class Encoding {

	constructor(items, scene, channel, field, args) {
		this.items = items;
		this.anyItem = this.items[0];
		this.scene = scene;
		this.channel = channel;
		this.field = field;
		this._aggregator = args.aggregator;
		this.datatable = args.datatable;
		this.scale = args.scale;
		//flipScale, scale type and includeZero will be ignored if reusing a scale
		//these should be considered properties of a scale, not encoding
		//same for scheme and mapping
		if (this.scale) {
			this._flipScale = this.scale.isFlipped;
			this.scaleType = this.scale.type;
			this._includeZero = this.scale.includeZero;
		} else {
			this._flipScale = args.flipScale;
			this.scaleType = args.scaleType;
			this._includeZero = args.includeZero;
		}
		this._mapping = args.mapping;
		this.rangeExtent = args.rangeExtent;
		this._scheme = args.scheme;
		this.range = args.range;

		if (this.channel == "angle") {
			this.startAngle = "startAngle" in args ? args.startAngle : 90;
			// this.angleDirection = "angleDirection" in args ? args.angleDirection : "clockwise";
		}

		//get the data needed for the mapping
		this._query = undefined;

		//construct/modify scales
		this._map = undefined;

		//apply mapping
		this._apply = undefined;
	}

	get id() {
		return ["enc", getEncodingKey(this.anyItem), this.channel, this.field].join("-");
	}

	set aggregator(a) {
		this._aggregator = a;
		//this.scale = undefined;
		this.run();
	}

	get aggregator() {
		return this._aggregator;
	}

	toJSON() {
		let json = {};
		json.anyItem = this.anyItem.id;
		json.items = this.items.map(d => d.id);
		if (this.data)
			json.data = this.data;
		if (this._rectNegativeValues)
			json._rectNegativeValues = true;
		json.args = {};
		json.args.channel = this.channel;
		json.args.field = this.field;
		json.args.aggregator = this.aggregator;
		json.args.datatable = this.datatable.id;
		json.args.scale = this.scale.id;
		//json.args.includeZero = this._includeZero;
		//json.args.flip = this.flip;
		json.args.mapping = this._mapping;
		json.args.rangeExtent = this.rangeExtent;
		json.args.scheme = this._scheme;
		json.args.scaleType = this.scaleType;
		json.args.range = this.range;

		if (this.channel == "angle") {
			json.args.startAngle = this.startAngle;
			//json.args.angleDirection = this.angleDirection;
		}

		return json;
	}

	run() {
		this._query();
		this._map();
		this._apply();
	}

	get dataTable() {
		return this.datatable;
	}

	_inferTickValues() {
        let enc = this, domain = enc.scale.domain, range = enc.scale.range;
		// if (this.datatable.getFieldType(this.field) == DataType.String)
		// 	return domain;
		let minPxInterval;
		//let minTickIntervalPx = 40, minLabelIntervalPx = 80;
		switch (enc.scale.type) {
			case "linear":
			case "log": {
				//handle the case where the marks are stacked
				let r = Math.abs(range[0] - range[1]);
				if (enc.channel == "width" || enc.channel == "height") {
					// let layout = getClosestLayout(enc.anyItem);
					// if (layout && layout.type == LayoutType.Stack) {
					// 	let c = layout.group, colls = getPeers(c, enc.scene);
					// 	r = Math.max(...colls.map(d => d.bounds[enc.channel])) ;
					// 	domain[1] = enc.scale.invert(r); // Math.ceil(enc.scale.invert(r)); do not ceil, it can amplify small difference in invert calculation due to imprecision/roundoff in bounding box calculation
					// }
					let layout = getTopLevelLayout(enc.anyItem, "stack");
					if (layout) {
						let c = layout.group, colls = getPeers(c, enc.scene);
						r = Math.max(...colls.map(d => d.refBounds[enc.channel]));
						domain[1] = enc.scale.invert(r); // Math.ceil(enc.scale.invert(r)); do not ceil, it can amplify small difference in invert calculation due to imprecision/roundoff in bounding box calculation
					}
				} 
				minPxInterval = enc.channel == "width" || enc.channel == "x" ? 45 : 30;
				let n = Math.max(2, Math.floor(r/minPxInterval));
				let ticks;
				if (enc.scale.type === "log") {
					ticks = [];
					let d3Ticks = enc.scale._scale.ticks();
					//number of ticks is not configurable for d3 log scales,
					//use the solution posted here: https://github.com/d3/d3/issues/72
					for (let d of d3Ticks) {
						let x = Math.log(d) / Math.log(10) + 1e-6;
						if (Math.abs(x - Math.floor(x)) < n/d3Ticks.length)
							ticks.push(d);
					}
				} else {
					ticks = d3.ticks(domain[0], domain[1], n);
				}
				return ticks;
			}
			case "point": {
				minPxInterval = enc.channel == "width" || enc.channel == "x" ? 80 : 30;
				let domainValueIntervalPx = Math.floor(enc.scale.rangeExtent/domain.length);
				let m = Math.ceil(minPxInterval/domainValueIntervalPx);
				return enc.channel == "x" ? domain.filter((d, i) => i % m == 0) : domain;
			}
			case "time": {
				minPxInterval = enc.channel == "width" || enc.channel == "x" ? 80 : 30;
				let numIntervals = Math.floor((range[1] - range[0])/minPxInterval),
					timeInterval = Math.ceil( (domain[1] - domain[0])/numIntervals )/1000;

				let units = [1, 60, 3600, 86400, 2628003, 31536000],
					intervals = [d3.timeSeconds, d3.timeMinutes, d3.timeHours, d3.timeDays, d3.timeMonths, d3.timeYears];

				let tn, tInterval;
				for (let i = 0; i < units.length - 1; i++) {
					if (timeInterval >= units[i] && timeInterval < units[i+1]) {
						tn = Math.floor(timeInterval/units[i]);
						tInterval = intervals[i];
						return tInterval(domain[0], domain[1], tn);
					}
				} 
				if (timeInterval > units[units.length-1]) {
					tn = Math.floor(timeInterval/units[units.length-1]);
					tInterval = intervals[units.length-1];
					return tInterval(domain[0], domain[1], tn);
				}
				return [];
			}
			default:
				return [];
		}
    }

	//optional itm specifies which scale range to get in the case of small multiples
	getScaleRange(itm) {
		let item = itm ? itm : this.anyItem;
		if (item.type == ItemType.Area || (item.type == "vertex" && item.parent.type == ItemType.Area)) {
			let area = item.type == ItemType.Area ? item : item.parent;
			let AreaOrientation = CheckAreaOrien(area);
			let layout = getClosestLayout(area);
			let alignment;
			if (layout) {
				if (AreaOrientation == Orientation.Vertical) {
					alignment = layout.horzCellAlignment === Alignment.Left;
				} else {
					alignment = layout.vertCellAlignment === Alignment.Bottom;
				}
				// alignment = AreaOrientation == Orientation.Vertical ? 
				// 				(layout.type == LayoutType.Stack ? 
				// 					layout._horzCellAlignment == Alignment.Left : layout._cellHorzAlignment == Alignment.Left) 
				// 				: (layout.type == LayoutType.Stack ? layout._vertCellAlignment == Alignment.Bottom : layout._cellVertAlignment == Alignment.Bottom)
			}
			else {
				alignment = AreaOrientation == Orientation.Vertical ? area.baseline == Alignment.Left : area.baseline == Alignment.Bottom;
			}
			// let DomainToBaseline = this.scale.domain[1] > this.scale.domain[0] ? "default" : "opposite"; // controlling the alignment for the axis and the chart
			let cb = getCellBoundsInGridLayout(area);
			if (cb) {
				switch (this.channel) {
					case "x":
						return [cb.left, cb.left + this.scale.rangeExtent];
					case "width":
						return alignment ? [cb.left, cb.left + this.scale.rangeExtent] : [cb.right, cb.right - this.scale.rangeExtent];
					case "y":
						return [cb.bottom, cb.bottom - this.scale.rangeExtent];
					case "height":
						return alignment ? [cb.bottom, cb.bottom - this.scale.rangeExtent] : [cb.top + this.scale.rangeExtent, cb.top];
				}
			} else if (layout && layout.type === "stack") {
				cb = layout.group.bounds;
				switch (this.channel) {
					case "x":
						return [cb.left, cb.left + this.scale.rangeExtent];
					case "width":
						return alignment ? [cb.left, cb.left + this.scale.rangeExtent] : [cb.right, cb.right - this.scale.rangeExtent];
					case "y":
						return [cb.bottom, cb.bottom - this.scale.rangeExtent];
					case "height":
						return alignment ? [cb.bottom, cb.bottom - this.scale.rangeExtent] : [cb.top + this.scale.rangeExtent, cb.top];
				}
			}
			if (AreaOrientation == Orientation.Horizontal){
				switch (this.channel) {
					case "width":
					case "height": {
						let vertices = this._vertices; // getPeers(item.firstVertex, this.scene);
						let offset = alignment ? Math.max(...vertices.map(d => d["y"])) : Math.min(...vertices.map(d => d["y"]));
						return alignment ? [offset, offset - this.scale.rangeExtent] : [offset + this.scale.rangeExtent, offset];
					}
					case "x":
					case "y": {
						let vertices = getPeers(area.firstVertex, this.scene);
						let offset = Math.min(...vertices.map(d => d["x"]));
						return [offset, offset + this.scale.rangeExtent];
					}
				}
			} else if (AreaOrientation == Orientation.Vertical){
				switch (this.channel) {	
					case "x":
					case "y": {
						let vertices = getPeers(area.firstVertex, this.scene);
						let offset = Math.max(...vertices.map(d => d["y"]));
						return [offset, offset - this.scale.rangeExtent];
					}
					case "height":
					case "width": {
						let vertices = getPeers(area.firstVertex, this.scene);
						let offset = alignment ? Math.min(...vertices.map(d => d["x"])) : Math.max(...vertices.map(d => d["x"]));
						return alignment ? [offset, offset + this.scale.rangeExtent] : [offset - this.scale.rangeExtent, offset];
					}
				}
			}
		} else if (this.channel == "x") {
			let layout = getClosestLayout(item);
			if (layout && layout.type == LayoutType.Grid){
				let cellBounds = layout.cellBounds;
				let parentPeers = item.parent.parent.children;
				let idx = parentPeers.findIndex(d => item.parent == d || item.parent.parent == d );
				return [cellBounds[idx].left, cellBounds[idx].left + this.scale.rangeExtent];
			} else if (item.type == "vertex" || item.type == "segment") {
				let offset = this.scale.offset;
				return [offset, offset + this.scale.rangeExtent];
			} else {
				let offset = this.scale.offset;
				return [offset, offset + this.scale.rangeExtent];
			}
			
		} else if (this.channel == "y") {
			let layout = getClosestLayout(item);
			if (layout && layout.type == LayoutType.Grid){
				let cellBounds = layout.cellBounds;
				let parentPeers = item.parent.parent.children;
				let idx = parentPeers.findIndex(d => item.parent == d || item.parent.parent == d );
				// if (isMark(item)) //need to take into account of mark size, cannot based in bounds bottom alone (e.g., calendar heatmap)
				// 	return [cellBounds[idx].bottom - item.bounds.height/2, cellBounds[idx].bottom - item.bounds.height/2 - this.scale.rangeExtent];
				// else
					return [cellBounds[idx].bottom, cellBounds[idx].bottom - this.scale.rangeExtent];
			} else if (item.type == "vertex" || item.type == "segment") {
				let offset = this.scale.offset;
				return [offset+ this.scale.rangeExtent, offset];
			} else {
				let offset = this.scale.offset;
				return [offset+ this.scale.rangeExtent, offset];
			}

		} else if (this.channel == "width") {
			let layout = getTopLevelLayout(item);
			if (layout.type === "grid") {
				let cellBounds = layout.cellBounds;
				let parentPeers = item.parent.parent.children;
				let idx = parentPeers.findIndex(d => item.parent == d || item.parent.parent == d );
				// return [cellBounds[idx].left, cellBounds[idx].left + this.scale.rangeExtent];
				return [cellBounds[idx].left, cellBounds[idx].right];
			} else if (layout.type === "stack" && layout.orientation == "horizontal") {
				return [layout.group.bounds.left, layout.group.bounds.right];
			} else {
				let items = getPeers(item, this.scene);
				let offset = Math.min(...items.map(d => d.bounds.left));
				return [offset, offset + this.scale.rangeExtent];
			}
		} else if (this.channel == "height") {
			let c = getTopLevelCollection(item);
			//let layout = getTopLevelLayout(item, "grid");
			if (c && c.layout && ["grid", "stack"].indexOf(c.layout.type) >= 0){
				let cellBounds = c.layout.cellBounds;
				let parentPeers = item.parent.parent.children;
				let idx = parentPeers.findIndex(d => item.parent === d || item.parent.parent === d );
				//return [cellBounds[idx].bottom, cellBounds[idx].bottom - this.scale.rangeExtent];
				//do not use rangeExtent because of possible stacking
				return [cellBounds[idx].bottom, cellBounds[idx].bottom - cellBounds[idx].height];
			} else {
				let items = getPeers(item, this.scene);
				//TODO: handle cases where items are aligned top
				let offset = Math.max(...items.map(d => d.refBounds.bottom));
				return [offset, offset - this.scale.rangeExtent];
			}
		} else if (this.channel == "radialDistance") {
			let polygon = item.parent;
			return [polygon.x, polygon.x + this.scale.rangeExtent];
		} else {
			return this.scale.range;
		}
	}

}