import Collection from "../item/composite/Collection";
import Glyph from "../item/composite/Glyph";
import Group from "../item/composite/Group";
import Mark from "../item/mark/Mark";
import { atlas_rowId, ConstraintType, ItemType, LayoutType } from "../util/Constants";
import { getEncodingKey, getPeers } from "../util/ItemUtil";

/**
 * Generates an array of commands that would reconstruct a given scene
 */
export default class SpecGenerator {

    constructor() {
        this.axes = {};
        this.guideCmds = [];
        this.collectionCmds = [];
        this.glyphCmds = [];
        this.spec = [];
    }

    run(scene) {
        for (let c of scene.children) {
            switch (c.type) {
                case ItemType.Axis: {
                    let id = c.classId ? c.classId : c.id;
                    this.axes[id] = c;
                    break;
                }
                case ItemType.Gridlines:
                case ItemType.Legend:{
                    let json = c.toJSON();
                    this.guideCmds.push({
                        cmd: c.type,
                        channel: json.channel,
                        field: json.field,
                        args: json.args
                    });
                    break;
                }
                case ItemType.Collection:
                case ItemType.Group:
                case ItemType.Glyph: {
                    let struct = [];
                    this._analyze(c, struct);
                    // console.log("struct", c.type);
                    // for (let s of struct)
                    //     console.log(s);
                    for (let i = struct.length - 1; i > 0; i--) {
                        for (let f of struct[i].fields)
                            struct[i - 1].fields.delete(f);
                    }
                    for (let [i, s] of struct.entries()) {
                        if (s.item instanceof Mark) {
                            let m = {
                                cmd: "mark",
                                type: s.item.type,
                                output: s.item,
                                args: s.item.toJSON().args
                            };
                            this._inferMarkArgs(m, scene);
                            this.collectionCmds.push(m);
                        } else if (s.item instanceof Glyph) {
                            this.collectionCmds.push({
                                cmd: "glyph",
                                output: s.item,
                                input: struct.slice(0, i).map(d => d.item),
                                args: {}
                            })
                        } else if (s.item instanceof Collection) {
                            let f = [...struct[i-1].fields][0];
                            let o = {
                                cmd: "join",
                                input: struct[i-1].item,
                                output: s.item,
                                data: struct[i-1].item.dataScope.dataTable.id,
                                args: {field: f}
                            };
                            if (f == atlas_rowId)
                                delete o.field;
                            this.collectionCmds.push(o);
                        }

                        if (s.item.dataScope && s.item.dataScope.fields.length == 0 && !s.item.parent.dataScope) {
                            this.collectionCmds.push({
                                cmd: "attach",
                                input: s.item,
                                data: s.item.dataScope.dataTable.id
                            });
                        }
                    }
                    break;
                }
                default:
                    if (c instanceof Mark) {
                        let m = {
                            cmd: "mark",
                            type: c.type,
                            output: c,
                            args: c.toJSON().args
                        };
                        this._inferMarkArgs(m, scene);
                        this.glyphCmds.push(m);
                    }
                    break;
            }
        }

        this._inferJoin();
        this._inferArgs(scene);

        for (let a in this.axes){
            let json = this.axes[a].toJSON();
            this.guideCmds.push({
                cmd: json.type,
                channel: json.channel,
                field: json.field,
                args: json.args
            });
        }

        // console.log("collection commands");
        // for (let c of this.collectionCmds)
        //     console.log(c);
        // console.log("glyphs", this.glyphCmds);
        // console.log("guides", this.guideCmds);

        this._generateFullSpec(scene);
        return this.spec;
    }

    _inferJoin() {
        for (let c of this.collectionCmds) {
            if (c.cmd != "join") continue;
            let itm = c.input, p = itm.parent;
            switch (itm.type) {
                case ItemType.Rect:
                    if (p.layout && p.layout.type == LayoutType.Stack)
                        c.cmd = "divide";
                    else
                        c.cmd = "repeat";
                    break;                    
                default:
                    c.cmd = "repeat";
                    break;
            }
        }
    }

    _inferArgs(scene) {
        for (let c of this.collectionCmds) {
            switch(c.cmd) {
                case "mark":
                    this._inferMarkArgs(c, scene);
                    break;
                case "divide":
                    this._inferDivideArgs(c, scene);
                    break;
            }
        }
    }

    _inferDivideArgs(c) {
        c.args.orientation = c.output.layout.orientation;
    }

    _inferMarkArgs(c, scene) {
        let itm = c.output, p = itm.parent;
        let itmPeers = getPeers(itm, scene), parentPeers = getPeers(p, scene);
        switch (itm.type) {
            case ItemType.Rect:
                if (p.layout && p.layout.type == LayoutType.Grid) {
                    c.args.width = p.layout.cellBounds[0].width;
                    c.args.height = p.layout.cellBounds[0].height;
                } else if (p.layout && p.layout.type == LayoutType.Stack) {
                    c.args.width = Math.max(...parentPeers.map(d => d.bounds.width));
                    c.args.height = Math.max(...parentPeers.map(d => d.bounds.height));
                } else {
                    c.args.width = Math.max(...itmPeers.map(d => d.bounds.width));
                    c.args.height = Math.max(...itmPeers.map(d => d.bounds.height));
                }
                c.args.left = Math.min(...itmPeers.map(d => d.bounds.left));
                c.args.top = Math.min(...itmPeers.map(d => d.bounds.top));
                break;
            case ItemType.Line:
                c.args.x1 = Math.min(...itmPeers.map(d => d.vertices[0].x));
                c.args.y1 = Math.min(...itmPeers.map(d => d.vertices[0].y));
                c.args.x2 = Math.min(...itmPeers.map(d => d.vertices[1].x));
                c.args.y2 = Math.min(...itmPeers.map(d => d.vertices[1].y));
                break;
            case ItemType.Arc:
                c.args.x = itm.x;
                c.args.y = itm.y;
                c.args.innerRadius = itm.innerRadius;
                c.args.outerRadius = itm.outerRadius;
                break;
            default:
                break;
        }
        for (let s in itm.styles) {
            c.args[s] = itm.styles[s];
        }
    }

    _analyze(itm, result) {
        if (itm instanceof Glyph) {
            for (let c of itm.children) 
                this._analyze(c, result);    
        } else if (itm instanceof Group) {
            this._analyze(itm.firstChild, result);
        }

        let node = {type: itm.type, item: itm};
        if (itm.dataScope)
            node.fields = new Set(itm.dataScope.fields);
        else
            node.fields = new Set();
        result.push(node);  
    }

    _generateFullSpec(scene) {
        this.spec = [];
        this.spec.push({
            cmd: "scene",
            args: {fillColor: scene.fillColor}
        });

        let tables = scene.getDataTables(); //, sourceTables = {};
        let imports = {}, transforms = [];
        for (let t in tables) {
            let table = tables[t];
            if (table.sourceDataTable) {
                while (table.sourceDataTable) {
                    transforms.push({
                        cmd: "transform",
                        type: table.transform.type,
                        args: table.transform.args,
                        input: table.sourceDataTable.id,
                        output: table.id
                    });
                    table = table.sourceDataTable;
                }
            }
            if (!(table.id in imports)) {
                imports[table.id] = {
                    cmd: "data",
                    url: table.url,
                    output: table.id
                };
            }
        }

        this.spec = this.spec.concat(Object.values(imports));
        this.spec = this.spec.concat(transforms);

        let sortChildren = [];

        for (let c of this.collectionCmds) {  
            let l;         
            if (c.output && c.output.layout) {
                l = {
                    cmd: "layout",
                    type: c.output.layout.type,
                    input: c.output.id,
                    args: c.output.layout.toJSON().args
                };
            }
            this.spec.push(c);
            if (c.output && c.output.childrenOrder) {
                sortChildren.push({
                    cmd: "sortChildren",
                    args: c.output.childrenOrder,
                    input: c.output.id
                })
            }
            if (l)
                this.spec.push(l);
            
            if (c.input && Array.isArray(c.input)) { //glyph
                c.input = c.input.map(d => d.classId ? d.classId : d.id);
            } else if (c.input)
                c.input = c.input.classId ? c.input.classId : c.input.id;
            if (c.output)
                c.output = c.output.classId ? c.output.classId : c.output.id;
        }

        let scales = {}, encodings = [];
        for (let classId in scene.encodings) {
            for (let channel in scene.encodings[classId]) {
                let enc = scene.encodings[classId][channel];
                if (enc.scale && !(enc.scale.id in scales)) {
					scales[enc.scale.id] = enc.scale.toJSON();
				}
                let args = enc.toJSON().args;
                args.field = enc.field;
                args.channel = enc.channel;
                delete args.datatable;
                encodings.push({
                    cmd: "encode",
                    input: getEncodingKey(enc.anyItem),
                    scale: enc.scale.id,
                    args: args
                });
            }
        }

        for (let s in scales) {
            let o = scales[s];
            o.cmd = "scale";
            this.spec.push(o);
        }

        this.spec = this.spec.concat(encodings);
        this.spec = this.spec.concat(sortChildren);

        for (let c in scene.constraints) {
            let constr = scene.constraints[c];
            let o = {
                cmd: "constraint",
                type: constr.type,
                args: {}
            };
            switch (constr.type) {
                case ConstraintType.Affix:
                    o.item = constr.item.classId ? constr.item.classId : constr.item.id;
                    o.baseItem = constr.baseItem.classId ? constr.baseItem.classId : constr.baseItem.id;
                    o.channel = constr.channel;
                    o.args.itemAnchor = constr.itemAnchor;
                    o.args.baseAnchor = constr.baseAnchor;
                    o.args.offset = constr.offset;
                    break;
                case ConstraintType.Align:
                    //TODO: need to actually do more to infer what items are being aligned
                    o.items = constr.items.map(d => d.classId ? d.classId : d.id);
                    o.anchor = constr.anchor;
                    break;
            }
            this.spec.push(o);
        }

        for (let c of this.guideCmds) {
            this.spec.push(c);
        }

        for (let c of this.glyphCmds) {
            if (c.output)
                c.output = c.output.classId ? c.output.classId : c.output.id;
            this.spec.push(c);
        }
    }
}