import Rectangle from "../basic/Rectangle";
import AffixConstraint from "../constraint/AffixConstraint";
import AlignConstraint from "../constraint/AlignConstraint";
import DataScope from "../data/DataScope";
import DataTable from "../data/DataTable";
import Segment from "../item/Segment";
import Vertex from "../item/Vertex";
import { ItemType, LayoutType } from "../util/Constants";
import { getLayout, isPath, ItemCounter } from "../util/ItemUtil";
import Scale from "./Scale";
import Scene from "mascot-svg-only/src/item/composite/Scene";
import LinearGradient from "../basic/Gradient";

export default class SceneLoader {

    constructor() {
        this.axes = {};
        this.legends = [];
        this.gridlines = [];
        this.scales = {};
        this.tables = {};
    }

    load(json) {
        //console.log("saved", json);
        let sceneArgs = {};
        if (json.fillColor)
            sceneArgs.fillColor = json.fillColor;
        if (json.itemCounter) {
            for (let t in json.itemCounter)
                ItemCounter[t] = json.itemCounter[t];
        }
        let scn = new Scene(sceneArgs);
        scn.id = json.id;
        scn.type = json.type;
        if (json.bounds)
            scn._bounds = new Rectangle(json.bounds.left, json.bounds.top, json.bounds.width, json.bounds.height);

        if (json.tables) {
            for (let t in json.tables) {
                this.tables[t] = new DataTable(json.tables[t].data, json.tables[t].url, json.tables[t].fieldTypes);
                this.tables[t].id = json.tables[t].id;
            }
        }

        for (let c of json.children) {
            this._processItem(scn, c, scn);
        }

        if (json.scales) {
            for (let s in json.scales)
                this._loadScale(json.scales[s], scn);
        }

        if (json.encodings) {
            for (let e of json.encodings) {
                this._loadEncoding(e, scn);
            }
        }

        if (json.constraints) {
            for (let c in json.constraints)
                this._loadConstraint(json.constraints[c], scn);
        }

        for (let a in this.axes) {
            this._createGuide(scn, this.axes[a]);
        }

        for (let l of this.legends) {
            this._createGuide(scn, l);
        }

        for (let l of this.gridlines) {
            this._createGuide(scn, l);
        }

        //console.log("loaded", scn);
        return scn;
    }

    _loadScale(s, scn) {
        let scale;
        // if (s.type === "sequentialColor" && s.scheme) {
        if (s.type.indexOf("Color") > 0 && s.scheme) {
            scale = new Scale(s.type, s.scheme);
        } else {
            scale = new Scale(s.type);
            scale.range = s.range;
        }
        scale.domain = s.type == "time" ? s.domain.map(d => new Date(d)) : s.domain;
        scale.id = s.id;
        if ("offset" in s)
            scale.offset = s.offset;
        scale.isFlipped = s.isFlipped;
        scale.clamp = s.clamp;
        scale._mapping = s.mapping;
        if ("includeZero" in s)
            scale.includeZero = s.includeZero;
        if ("baseItem" in s)
            scale._baseItem = scn.getItem(s.baseItem);
        this.scales[scale.id] = scale;
        //console.log(scale.domain, scale.range);
    }

    _loadEncoding(enc, scene) {
        if (enc.args.datatable)
            enc.args.datatable = this.tables[enc.args.datatable];
        if (enc.args.scale) {
            enc.args.scale = this.scales[enc.args.scale];
        }
        //let item = scene.getItem(enc.anyItem);
        let items = enc.items.map(d => scene.getItem(d));
        scene._doEncode(items, enc.args);
        scene._relayoutAncestors(items[0], items);
    }

    _createGuide(scene, guide) {
        switch (guide.type) {
            case ItemType.Axis:
                if (guide.args.item) {
                    guide.args.item = scene.getItem(guide.args.item);
                }
                scene.axis(guide.channel, guide.field, guide.args);
                break;
            case ItemType.Legend:
                scene.legend(guide.channel, guide.field, guide.args);
                break;
            case ItemType.Gridlines:
                if (guide.args.item) {
                    guide.args.item = scene.getItem(guide.args.item);
                }
                scene.gridlines(guide.channel, guide.field, guide.args);
                break;
        }
    }

    _processItem(parent, itm, scene) {
        switch (itm.type) {
            case ItemType.Axis: {
                let id = itm.classId ? itm.classId : itm.id;
                if (itm.args.tickValues && itm.args.isDate) {
                    itm.args.tickValues = itm.args.tickValues.map(d => new Date(d));
                }
                this.axes[id] = itm;
                break;
            }
            case ItemType.Gridlines:
                if (itm.args.values && itm.args.isDate) {
                    itm.args.values = itm.args.values.map(d => new Date(d));
                }
                this.gridlines.push(itm);
                break;
            case ItemType.Legend:
                this.legends.push(itm);
                break;
            case ItemType.Collection: {
                let coll = scene.collection();
                parent.addChild(coll);
                this._loadGroup(coll, itm, scene);
                break;
            }
            case ItemType.Group: {
                let g = scene.group();
                parent.addChild(g);
                this._loadGroup(g, itm, scene);
                break;
            }
            case ItemType.Glyph: {
                let glyph = scene.glyph();
                parent.addChild(glyph);
                this._loadGroup(glyph, itm, scene);
                break;
            }
            default:
                this._loadMark(parent, itm, scene);
                break;
        }
    }

    _loadConstraint(c, scene) {
        switch (c.type) {
            case "affixation": {
                let item = scene.getItem(c.item), baseItem = scene.getItem(c.baseItem);
                let cstr = new AffixConstraint(item, baseItem, scene, c.channel, c.itemAnchor, c.baseAnchor, c.offset);
                cstr.id = c.id;
                scene.constraints[c.id] = cstr;
                cstr.apply();
                return cstr;
            }
            case "alignment": {
                let items = c.items.map(d => scene.getItem(d));
                let cstr = new AlignConstraint(items, c.direction);
                cstr.id = c.id;
                scene.constraints[c.id] = cstr;
                cstr.apply();
                return cstr;
            }
        }
    }

    _loadDataScope(ds) {
        let scope = new DataScope(this.tables[ds.dt]);
        for (let f in ds.f2v) {
            scope._field2value[f] = ds.f2v[f];
            scope._updateTuples(f, ds.f2v[f]);
        }
        return scope;
    }

    _loadGroup(coll, itm, scene) {
        coll.id = itm.id;
        if (itm.classId)
            coll.classId = itm.classId;
        if (itm.dataScope)
            coll.dataScope = this._loadDataScope(itm.dataScope);
        if (itm.children) {
            for (let c of itm.children) {
                this._processItem(coll, c, scene);
            }
        }
        if (itm.layout) {
            let l = this._loadLayout(itm.layout);
            l.group = coll;
            coll._layout = l;
        }
        if (itm.bounds)
            coll._bounds = new Rectangle(itm.bounds.left, itm.bounds.top, itm.bounds.width, itm.bounds.height);
    }

    _loadMark(parent, itm, scene) {
        if (itm.args.fillColor && itm.args.fillColor.type === "LinearGradient") {
            let g = itm.args.fillColor;
            itm.args.fillColor = new LinearGradient(g);
            itm.args.fillColor.id = g.id;
            itm.args.fillColor._stops = g.stops;
        }
        if ("id" in itm)
            itm.args.id = itm.id;
        let mark = scene.mark(itm.type, itm.args);
        if (itm.classId)
            mark.classId = itm.classId;
        if (itm.dataScope)
            mark.dataScope = this._loadDataScope(itm.dataScope);
        if (itm.vertices) {
            const vertices = [];
            for (let d of itm.vertices) {
                const v = Vertex.fromJSON(d, mark);
                if (v.dataScope)
                    v.dataScope = this._loadDataScope(v.dataScope);
                vertices.push(v);
            }
            mark.vertices = vertices;
            //TODO: modify instead of replace segments
            mark.segments = [];
            for (let i = 1; i < mark.vertices.length; i++)
                mark.segments.push(new Segment(mark.vertices[i-1], mark.vertices[i], mark, mark.segmentCounter++));
        }
        if (itm.bounds)
            mark._bounds = new Rectangle(itm.bounds.left, itm.bounds.top, itm.bounds.width, itm.bounds.height);
        if (itm.boundsOffsets)
            mark.boundsOffsets = itm.boundsOffsets;
        if (isPath(mark)) {
            mark.vertexCounter = itm.vertexCounter;
            mark.segmentCounter = itm.segmentCounter;
            mark.curveMode = itm.curveMode;
        } else if (itm.type === ItemType.Image) {
            mark.src = itm.src;
            mark.width = itm.width;
            mark.height = itm.height;
            mark.x = itm.x;
            mark.y = itm.y;
        }
        parent.addChild(mark);
    }

    _loadLayout(l) {
        let lo = getLayout(l.type, l.args);
        switch (l.type) {
            case LayoutType.Grid:
                lo._left = l.left;
                lo._top = l.top;
                break;
            default:
                break;
        }
        return lo;
    }

}