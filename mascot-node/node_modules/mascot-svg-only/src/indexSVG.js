import * as d3 from "d3";
import Scene from "mascot-svg-only/src/item/composite/Scene";
import SVGRenderer from "./renderer/SVGRenderer";
import DataTable from "./data/DataTable";
import Scale from "./core/Scale";
import {ItemType} from "./util/Constants";
import {CanvasProvider, cartesian2Polar, getLayout, getLeafItems, getLeafMarks, getPeers, isGuide, isMark, polar2Cartesian} from "./util/ItemUtil";
import LinearGradient from "./basic/Gradient";
import SpecGenerator from "./core/SpecGenerator";
import SceneLoader from "./core/SceneLoader";
import SpecExecutor from "./core/SpecExecutor";
import Rectangle from "./basic/Rectangle";
import Path from "./item/mark/Path";
import { classifiable } from "./action/Classify";
import { densifiable } from "./action/Densify";
import { dividable } from "./action/Partition";
import { repeatable } from "./action/Repeat";
import { importCSV, importGraphjson, importTreejson } from "./data/DataImporter";

export function scene(args) {
	return new Scene(args);
}

export function renderer(type, id) {
	return new SVGRenderer(id);
}

export function createScale(type, args) {
	return new Scale(type, args);
}

export function layout(type, params) {
	return getLayout(type, params);
}

export function linearGradient(params) {
	return new LinearGradient(params);
}

export function sceneLoader() {
	return new SceneLoader();
}

export function specGenerator() {
	return new SpecGenerator();
}

export function specExecutor() {
	return new SpecExecutor();
}




export async function csv(url) {
	return importCSV(url);
}

export async function csvFromFile(data) {
	let parsed = d3.csvParse(data.trim(), d3.autoType);
	return new DataTable(parsed, "");
}

export function csvFromString(data, name) {
	let parsed = d3.csvParse(data.trim(), d3.autoType);
	return new DataTable(parsed, name);
}

export async function treejson(url) {
	return importTreejson(url);
}

export async function graphjson(url) {
	return importGraphjson(url);
}

export function cartesianToPolar(x, y, cx, cy){
	return cartesian2Polar(x, y, cx, cy);
}

export function polarToCartesian(cx, cy, r, deg){
	return polar2Cartesian(cx, cy, r, deg);
}

export function inMarkRectHitTest(item, rect, tolerance) {
	let t = tolerance ? tolerance : 2;
	if (isMark(item)) {
		let list = [];
		for (let v of item.vertices) {
			let wd = Math.max(t, v.width, v.radius * 2), ht = Math.max(t, v.height, v.radius * 2);
			list.push({i: v, b: new Rectangle(v.x - wd/2, v.y - ht/2, wd, ht)});
		}
		if (item.type === ItemType.Rect) {
			for (let s of item.segments) {
				let tk = Math.max(item.strokeWidth, t), orientation = s.vertex1.x === s.vertex2.x ? "v" : "h";
				if (orientation === "v")
					list.push({i: s, b: new Rectangle(s.vertex1.x - tk/2, Math.min(s.vertex1.y, s.vertex2.y) - tk/2, tk, Math.abs(s.vertex1.y - s.vertex2.y))});
				else 
					list.push({i: s, b: new Rectangle(Math.min(s.vertex1.x, s.vertex2.x) - tk/2, s.vertex1.y - tk/2,  Math.abs(s.vertex1.x - s.vertex2.x), tk)});
			}
		}

		for (let l of list) {
			if (l.b.overlap(rect))
				return l.i;
		}
		return null;
	} else if (!isGuide(item) && item.children && item.children.length > 0) {
		for (let c of item.children) {
			if (c.bounds.overlap(rect)) {
				let r = inMarkRectHitTest(c, rect, t);
				if (r) return r;
			}
		}
		return null;
	}
	return null;
}

export function inMarkHitTest(item, x, y, tolerance) {
	// let itm = item, found = false, t = tolerance ? tolerance : 2;
	// while (itm.children && itm.children.length > 0) {
	// 	for (let c of itm.children) {
	// 		if (c.contains(x, y) && !isGuide(c)) {
	// 			itm = c;
	// 			found = true;
	// 			break;
	// 		}
	// 	}
	// 	if (found) {
	// 		found = false;
	// 	} else {
	// 		break;
	// 	}
	// }
	// if (!isMark(itm)) return null;
	let leafMarks = getLeafMarks(item);
	let itm, t = tolerance ? tolerance : 2;
	let ctx = CanvasProvider.getContext();
		
	for (let m of leafMarks) {
		if (!(m instanceof Path)) continue;
		let p = new Path2D(m.getSVGPathData());
		ctx.lineWidth = Math.max(m.strokeWidth, t * 2);
		ctx.stroke(p);
		if (ctx.isPointInStroke(p, x, y)) {
			itm = m;
			break;
		}
	}

	if (!itm) return null;
	
	let list = [];
	for (let v of itm.vertices) {
		let wd = Math.max(t, v.width, v.radius * 2), ht = Math.max(t, v.height, v.radius * 2);
		list.push({i: v, b: new Rectangle(v.x - wd/2, v.y - ht/2, wd, ht)});
	}
	for (let l of list) {
		if (l.b.contains(x, y))
			return l.i;
	}

	if (itm.segments && itm.segments.length > 0) {
		for (let s of itm.segments) {
			let p = new Path2D();
			p.moveTo(s.vertex1.x, s.vertex1.y);
			p.lineTo(s.vertex2.x, s.vertex2.y);
			ctx.lineWidth = Math.max(itm.strokeWidth, t);
			ctx.stroke(p);
			if (ctx.isPointInStroke(p, x, y))
				return s;
		}
	}
	// if (itm.type === ItemType.Rect) {
	// 	for (let s of itm.segments) {
	// 		let tk = Math.max(itm.strokeWidth, t), orientation = s.vertex1.x === s.vertex2.x ? "v" : "h";
	// 		if (orientation === "v")
	// 			list.push({i: s, b: new Rectangle(s.vertex1.x - tk/2, Math.min(s.vertex1.y, s.vertex2.y) - tk/2, tk, Math.abs(s.vertex1.y - s.vertex2.y))});
	// 		else 
	// 			list.push({i: s, b: new Rectangle(Math.min(s.vertex1.x, s.vertex2.x) - tk/2, s.vertex1.y - tk/2,  Math.abs(s.vertex1.x - s.vertex2.x), tk)});
	// 	}
	// }

	
	return null;
}
 
export function rectHitTest(item, rect) {
	let result = [];
	if (!item.children || item.children.length == 0) {
		return item.bounds.overlap(rect) && item.type !== ItemType.Scene ? [item] : [];
	}
	for (let i = item.children.length - 1; i >= 0; i--) {
		let c = item.children[i];
		if (c.bounds.overlap(rect))
			result.push(c);
	}
	return result;
}

export function hitTest(item, x, y) {
	if (!item.children || item.children.length == 0) {
		return item.contains(x, y) && item.type !== ItemType.Scene ? item : null
	}
	let children = item.children;
	if (item.type === ItemType.Scene) {
		children = children.slice();
		children.sort((a,b) => isGuide(a) ? 1 : isGuide(b) ? -1 : 0 );
	}
	for (let i = children.length - 1; i >= 0; i--) {
		let c = children[i];
		if (c.contains(x, y))
			return c;
	}
	return null;
}

export function hitTestAll(item, x, y) {
	let items = getLeafItems(item);
	for (let i = items.length - 1; i >= 0; i--) {
		let c = items[i];
		if (c.contains(x, y))
			return c;
	}
	return null;
}

export function canRepeat(compnt) {
	return repeatable(compnt);
}

export function canDivide(compnt) {
	return dividable(compnt);
}

export function canDensify(compnt) {
	return densifiable(compnt);
}

export function canFormGlyph(args) {
	for (let itm of args) {
		if (!isMark(itm))
			return false;
	}
	return true;
}

export function canClassify(item) {
	return classifiable(item);
}

export function getPeersInScene(item) {
	if (item.type == "vertex" || item.type == "segment") {
		return getPeers(item, item.parent.getScene());
	} else {
		return getPeers(item, item.getScene());
	}
}