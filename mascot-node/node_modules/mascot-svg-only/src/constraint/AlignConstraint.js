import { Alignment, ConstraintType, LayoutType, Orientation } from "../util/Constants";
import * as d3 from "d3";

export default class AlignConstraint {

    constructor(items, d) {
        //TODO: check if d is a value in the Alignment (refer to const Alignment in Constants.js)
        //if not, throw a new error (add an error type in Errors, also defined in Constants.js)

        this.direction = d;
        this.items = items;
        this.type = ConstraintType.Align;
        this._orientation = [Alignment.Top, Alignment.Middle, Alignment.Bottom].indexOf(d) >= 0 ? Orientation.Vertical : Orientation.Horizontal;
        this._itemIds = this.items.map(d => d.classId).sort().join("_");
        this.id = this.type + "_" + this._itemIds + "_" + this._orientation;
    }

    get orientation() {
        return this._orientation;
    }

    apply() {
        let baseline, dir = this.direction; 
        if (this.direction == Alignment.Top || this.direction == Alignment.Left)
            baseline = Math.min(...this.items.map(d => d.bounds[dir]));
        else if ((this.direction == Alignment.Bottom || this.direction == Alignment.Right))
            baseline = Math.max(...this.items.map(d => d.bounds[dir]));
        else if (this.direction == Alignment.Center || this.direction == Alignment.Middle)
            baseline = d3.mean(this.items.map(d => d.bounds[dir]));
        
        let delta = this.items.map(d => baseline - d.bounds[dir]),
            axis = dir == Alignment.Top || dir == Alignment.Middle || dir == Alignment.Bottom ? "y" : "x";
        this.items.forEach((d,i) => {
            if (d.parent && d.parent.layout && d.parent.layout.type == LayoutType.Stack){
                let dx = axis == "x" ? delta[i] : 0,
                    dy = axis == "y" ? delta[i] : 0;
                d.parent._doTranslate(dx, dy);
            } else {
                let dx = axis == "x" ? delta[i] : 0,
                    dy = axis == "y" ? delta[i] : 0;
                d._doTranslate(dx, dy);
            }
        });
        //TODO:  update bounds
        let itms = {};
        this.items.forEach(d => itms[d.classId] = d);
        Object.values(itms).forEach(d => d.getScene()._updateAncestorBounds(d)); 
    }

    toJSON() {
        let json = {};
        json.items = this.items.map(d => d.id);
        json.direction = this.direction;
        json.type = this.type;
        json.id = this.id;
        return json;
    }
}