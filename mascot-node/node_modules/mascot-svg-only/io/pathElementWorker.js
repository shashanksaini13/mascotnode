const puppeteer = require('puppeteer');
const fs = require('fs').promises;
const path = require('path');

async function main() {
    const browser = await puppeteer.launch({ headless: "new" }); //"new"
    const page = await browser.newPage();
    const json = await fs.readFile("../demos/static.json", 'utf8');
    let demos = JSON.parse(json);

    //demos = { 'CyclePlot': 21 };

    let marks = {};
    for (const d in demos) {
        if (demos[d].draft) continue;
        if (d === "Isotype") continue;
        const s = await fs.readFile("scene/" + d + ".msc", 'utf8');
        let scene = JSON.parse(s);

        const filePath = path.resolve(__dirname, 'svg', d + '.svg');
        await page.goto('file://' + filePath);
        await buildMarkHash(scene, page, marks, d);
    }

    await browser.close();

    let data = [["d", "type", "attrs"].join("\t") + "\n"];
    for (let k in marks) {
        data.push(marks[k].d + "\t" + marks[k].type + "\t" + JSON.stringify(marks[k].attrs) + "\n");
    }

    await checkDirectory('pathElements/');
    fs.writeFile('pathElements/pathMarks.tsv', data, (err) => {
        if (err) throw err;
      });
}

async function buildMarkHash(scene, page, marks, demo) {
    for (let c of scene.children)
        await getMarks(c, marks, page, demo);
}

async function getMarks(c, marks, page, demo) {
    let shapes = ['path', 'line', 'arc', 'pie', 'ring', 'polygon', 'area', 'link'];
    if (c.children && c.type !== "axis" && c.type !== "gridlines" && c.type !== "legend") {
        for (let child of c.children)
            await getMarks(child, marks, page, demo);
    } else if (shapes.indexOf(c.type) >= 0) {
        let element = await page.$('#' + c.id);
        let v = await page.evaluate((el, attributeName) => el.getAttribute(attributeName), element, 'd');
        let attrs = getMarkAttrs(c);
        marks[demo+"-"+c.id] = { "type": c.type, "d": v, "attrs": attrs };
    }
}

function getMarkAttrs(m) {
    switch (m.type) {
        case "arc":
            return {"cx": m.args.x, 'cy': m.args.y, "innerRadius": m.args.innerRadius, "outerRadius": m.args.outerRadius, "startAngle": m.args.startAngle, "endAngle": m.args.endAngle};
        case "pie":
            return {"cx": m.args.x, 'cy': m.args.y, "radius": m.args.outerRadius, "startAngle": m.args.startAngle, "endAngle": m.args.endAngle};
        case "ring":
            return {"cx": m.args.x, 'cy': m.args.y, "innerRadius": m.args.innerRadius, "outerRadius": m.args.outerRadius};
        case "polygon":
            return {"cx": m.args.x, 'cy': m.args.y, "radius": m.args.radius, "numPts": m.vertices.length};
        case "link": 
            return {"mode": m.mode, "sourceAnchor": m.args.sourceAnchor, "targetAnchor": m.args.targetAnchor, "sourceOffset": m.args.sourceOffset, "targetOffset": m.args.targetOffset};
        case "area":
        case "line":
        case "path":
        default:
            return {"numPts": m.vertices.length};
    }
}

async function directoryExists(dirPath) {
    try {
        await fs.access(dirPath);
        return true;
    } catch {
        return false;
    }
  }
  
  async function checkDirectory(dirPath) {
    if (!(await directoryExists(dirPath))) {
      await fs.mkdir(dirPath, { recursive: true });
    }
  }

main();