const puppeteer = require('puppeteer');
const fs = require('fs').promises;

const svgs = {}, scenes = {};

async function main() {
  const browser = await puppeteer.launch({ headless: "new" }); //false to debug
  const page = await browser.newPage();

  const json = await fs.readFile("../demos/static.json", 'utf8');
  let demos = JSON.parse(json);

  for (const d in demos) {
    if (demos[d].draft) continue;
    if (d === "Isotype") continue;
    await page.goto('http://localhost:8020/io/index.html#' + d, { waitUntil: 'networkidle0' });

    await page.waitForFunction((v) => window.demo == v, {}, d);
    const scene = await page.evaluate(() => window.scene);
    scenes[d] = scene;

    const svg = await page.$('#svgElement'); // selector for the element
    const text = await page.evaluate(s => s.outerHTML, svg);
    svgs[d] = text;
  }

  await browser.close();

  writeScenes();
  writeSVGs();
}

async function writeScenes() {
  await checkDirectory('scene/');
  await checkDirectory('annotation/');
  for (let d in scenes) {
    let scene = scenes[d];
    let annotation = {ID: scene.id, type: "scene", children: []};
    for (let c of scene.children)
      annotate(c, annotation.children);  
    fs.writeFile('scene/' + d + '.msc', JSON.stringify(scene));
    fs.writeFile('annotation/' + d + '.json', JSON.stringify(annotation));
  }
}

async function writeSVGs() {
  await checkDirectory('svg/');
  for (let d in svgs) {
    let scene = scenes[d];
    let wd = parseInt(scene.bounds.width + scene.bounds.left) + 50,
      ht = parseInt(scene.bounds.height + scene.bounds.top) + 80;
    const sizeInfo = `width="${wd}" height="${ht}" `;
    const content = svgs[d].replace('xmlns:xlink', sizeInfo + 'xmlns:xlink');
    fs.writeFile('svg/' + d + '.svg', content);
  }
}

async function directoryExists(dirPath) {
  try {
      await fs.access(dirPath);
      return true;
  } catch {
      return false;
  }
}

async function checkDirectory(dirPath) {
  if (!(await directoryExists(dirPath))) {
    await fs.mkdir(dirPath, { recursive: true });
  }
}

function annotate(node, result) {
  let n = {ID: node.id, type: node.type};
  switch (node.type) {
      case "collection":
          n.layout = node.layout? node.layout : {type: "none"}; 
          break;
      default:
          break;
  }
  result.push(n);
  if (node.children && node.children.length > 0) {
      n.children = [];
      for (let c of node.children)
          annotate(c, n.children);
  }
}

main();
