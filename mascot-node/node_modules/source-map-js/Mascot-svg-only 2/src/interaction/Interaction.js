import { evaluatePredicate, getPeers } from "../util/ItemUtil";
import * as d3 from 'd3';

export default class Interaction {

    constructor(listener, eventType, selDef, targetDef) {
        this._listener = listener;
        this._eventType = eventType;
        this._selDef = selDef;
        this._targetDef = targetDef;
    }

    getCallbackFunction(scene, handler) {
        let i = this;
        return function(e){
            e.stopPropagation();
            let sel = handler._getSelection(e, i.selectionDef, i._listener, scene.getItem(d3.select(this).attr("id")));
            let targets = getPeers(i.targetDef.item, scene);
            let predicates;
            if (i.selectionDef.remember) {
                handler.addGlobalPredicate(scene, sel.predicate);
                predicates = handler.getGlobalPredicates(scene);
            } else {
                predicates = handler.getGlobalPredicates(scene).concat([sel.predicate])
            }
            for (let t of targets) {
                let selected = true;
                for (let p of predicates) {
                    if (!evaluatePredicate(t, p)) {
                        selected = false;
                        break;
                    }
                }
                for (let c in i.targetDef.effect) {
                    if (!(c in t.staticProperties))
                        t.staticProperties[c] = t[c];
                    if (selected) {
                        t[c] = i.targetDef.effect[c].selected;
                    } else if ("unselected" in i.targetDef.effect[c]) {
                        t[c] = i.targetDef.effect[c].unselected;
                    } else if (c in t.staticProperties) {
                        t[c] = t.staticProperties[c];
                    }
                }
            }
            // console.log(handler.getGlobalPredicates(scene));
            handler._renderer.render(scene, {visualOnly: true});
        }
    }

    getRestoreFunction(scene, handler, clearGlobalPredicates) {
        let i = this;
        return function(){
            let targets = getPeers(i.targetDef.item, scene);
            if (i.targetDef.effect) {
                for (let t of targets) {
                    for (let c in i.targetDef.effect)
                        t[c] = t.staticProperties[c];
                    //delete t.staticProperties[c];
                }
            } else {
                for (let t of targets) {
                    for (let c in t.staticProperties)
                        t[c] = t.staticProperties[c];
                    //t.staticProperties = {};
                }
            }

            if (clearGlobalPredicates)
                handler._globalPredicates = {};
            
            handler._renderer.render(scene, {visualOnly: true});
        }
    }

    get listener() {
        return this._listener;
    }

    get selectionDef() {
        return this._selDef;
    }

    get targetDef() {
        return this._targetDef;
    }

    get eventType() {
        return this._eventType;
    }
}