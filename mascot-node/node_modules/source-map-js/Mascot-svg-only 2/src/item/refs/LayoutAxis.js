import { DataType, ItemType, LayoutType } from "../../util/Constants";
import Path from "../mark/Path";
import PointText from "../mark/PointText";
import Group from "../composite/Group";
import * as d3 from 'd3'; 
import Axis from "./Axis";
import { sameClass } from "../../util/ItemUtil";


export default class LayoutAxis extends Axis {
    
    constructor(items, layout, channel, field, args) {
        super(args);
        this._channel = channel;
        this._orientation = "orientation" in args ? args["orientation"] : 
                                this._channel === "x" || this._channel == "width" ? "bottom" : "left";
        this._posArg = this._channel == "x" || this._channel == "width"? args["pathY"] : args["pathX"]; 
        this._padding = [ItemType.Line, ItemType.Path].indexOf(items[0].type) >= 0 ? 10 : 0;

        this._item = items[0];
        this._items = items;
        this._mlayout = layout;
        this._field = field;
        this._titleText = "title" in args ? args["title"] : this._field;
        this._showTitle = "showTitle" in args ? args.showTitle : false;
        
        // if ("labelRotation" in args)
        //     this._labelRotation = args.labelRotation;

        this._ticks = new Group();
        this._ticks.id = this.id + "ticks";
        this.addChild(this._ticks);

        this._labels = new Group();
        this._labels.id = this.id + "labels";
        this.addChild(this._labels);

        //there can be multiple rules if the layout has multiple rows or columns
        this._rules = new Group();
        this._rules.id = this.id + "paths";
        this.addChild(this._rules);

        this._generatePath();
        this._generateTicks();
        this._generateLabels();
        if (this._showTitle) {
            this._generateTitle();
        }
        this._positionPath();
        this._positionTicks();
        this._positionLabels();
        if (this._showTitle) {
            this._positionTitle();
        }

    }

    toJSON() {
        let json = super.toJSON();
        json.args.item = this._item.id;
        if (this._channel == "x" || this._channel == "width")
            json.args.pathY = this._posArg;
        else
            json.args.pathX = this._posArg;
        if (this.classId)
            json.classId = this.classId;
        return json;
    }

    set strokeColor(c) {
        this._strokeColor = c;
        for (let t of this._ticks.children)
            t.strokeColor = c;
        for (let t of this._rules.children)
            t.strokeColor = c;
    }

    get strokeColor() {
        return this._strokeColor;
    }

    set textColor(c) {
        this._textColor = c;
        for (let l of this._labels.children)
            l.fillColor = c;
        if (this._title)
            this._title.fillColor = c;
    }

    get textColor() {
        return this._textColor;
    }

    _updateBounds() {
        this._bounds = this._rules.bounds.clone();
        this._bounds = this._bounds.union(this._ticks.bounds);
        this._bounds = this._bounds.union(this._labels.bounds);
        if (this._showTitle)
            this._bounds = this._bounds.union(this._title.bounds);
    }

    _generatePath(){
        this._rules.removeAll();
        if (this._mlayout.type == LayoutType.Grid) {
            let num = this._channel == "x" ? this._mlayout.numRows : this._mlayout.numCols;
            for (let i = 0; i < num; i++) {
                let t = new Path({"strokeColor": this._strokeColor});
                if (!this._pathVisible)
                    t.visibility = "hidden";
                t.type = ItemType.Line;
                t.id = this.id + "rule" + i;
                this._rules.addChild(t);
            }
        } else if (this._mlayout.type === LayoutType.Stack) {
            let t = new Path({"strokeColor": this._strokeColor});
            if (!this._pathVisible)
                t.visibility = "hidden";
            t.type = ItemType.Line;
            t.id = this.id + "rule";
            this._rules.addChild(t);
        }
    }

    _generateTicks() {
        this._ticks.removeAll();
        for (let i = 0; i < this._mlayout.group.children.length; i++) {
            let t = new Path({"strokeColor": this._strokeColor});
            if (!this._tickVisible)
                t.visibility = "hidden";
            t.type = ItemType.Line;
            t.id = this.id + "tick" + i;
            this._ticks.addChild(t);
        }
    }

    //TODO: improve efficiency by reusing components
    _generateLabels() {
        this._labels.removeAll();
        let formatter, fieldType = this._item.dataScope.getFieldType(this._field);

        switch (fieldType) {
            case DataType.Date:
                formatter = d3.timeFormat(this._labelFormat);
                break;
            case DataType.String:
                formatter = function(d) {return d;};
                break;
            default:
                formatter = d3.format(this._labelFormat);
                break;
        }
  
        let cb = this._mlayout.cellBounds;
        for (let i = 0; i < cb.length; i++) {
            if (i >= this._mlayout.group.children.length) break;
            let itm = this._mlayout.group.children[i];
            let t = new PointText({fillColor: this._textColor, fontSize: this._fontSize, "text": formatter(itm.dataScope.getFieldValue(this._field))});
            //let t = new PointText({fillColor: this._textColor, fontSize: this._fontSize, "text": formatter(this._items[i].dataScope.getFieldValue(this._field))});
            t.id = this.id + "label" + i;
            this._labels.addChild(t);
        }
    }

    _positionPath(){
        if (this._mlayout.type == LayoutType.Grid) {
            let cb = this._mlayout.cellBounds;
            let num = this._channel == "x" ? this._mlayout.numRows : this._mlayout.numCols;
            if (this._channel == "x") {
                let left = cb[0].left, numCols = this._mlayout.numCols;
                let padding = this._orientation === "bottom" ? this._padding : - this._padding;
                for (let r = 0; r < num; r++){
                    this._rules.children[r]._setVertices([
                        [left, this._posArg ? cb[r * numCols][this._orientation] + this._posArg - cb[0][this._orientation] : cb[r * numCols][this._orientation] + padding],
                        [left + cb[0].width * numCols + this._mlayout.colGap * (numCols - 1), this._posArg ? cb[r * numCols][this._orientation] + this._posArg - cb[0][this._orientation] : cb[r * numCols][this._orientation] + padding]
                    ]);
                }
            } else {
                let top = cb[0].top, numRows = this._mlayout.numRows;
                let padding = this._orientation === "left" ? this._padding : - this._padding;
                for (let c = 0; c < num; c++){
                    // this._rules.children[c]._setVertices([
                    //     [this._posArg ? cb[c * numRows][this._orientation] + this._posArg - cb[0][this._orientation] : cb[c * numRows][this._orientation], top ],
                    //     [this._posArg ? cb[c * numRows][this._orientation] + this._posArg - cb[0][this._orientation] : cb[c * numRows][this._orientation], top + cb[0].height * numRows + this._mlayout.rowGap * (numRows - 1), ]
                    // ]);
                    this._rules.children[c]._setVertices([
                        [this._posArg ? cb[c * numRows][this._orientation] + this._posArg - cb[0][this._orientation] : this._mlayout.group.bounds[this._orientation] - padding, top ],
                        [this._posArg ? cb[c * numRows][this._orientation] + this._posArg - cb[0][this._orientation] : this._mlayout.group.bounds[this._orientation] - padding, top + cb[0].height * numRows + this._mlayout.rowGap * (numRows - 1)]
                    ]);
                }
            }
        } else if (this._mlayout.type === LayoutType.Stack) {
            let b = this._mlayout.group.bounds;
            if (this._channel == "x") {
                this._rules.children[0]._setVertices([
                    [b.left, this._posArg ? this._posArg : b[this._orientation] ],
                    [b.right, this._posArg ? this._posArg : b[this._orientation]]
                ]);              
            } else {
                this._rules.children[0]._setVertices([
                    [this._posArg ? this._posArg : b[this._orientation], b.top ],
                    [this._posArg ? this._posArg : b[this._orientation], b.bottom ]
                ]);
            }
        }
        this._rules.children.forEach(r => r._updateBounds());
        this._rules._updateBounds();
        this._updateBounds();
    }

    _positionTicks(){
        let cb = this._mlayout.cellBounds;
        if (this._channel == "x") {
            let dir = this._orientation == "bottom" ? 1 : -1;
            let padding = this._orientation === "bottom" ? this._padding : - this._padding;
            for (let [i, t] of this._ticks.children.entries()) {
                let pos = this._posArg ? cb[i][this._orientation] + this._posArg - cb[0][this._orientation] + this._tickOffset * dir : 
                            cb[i][this._orientation] + this._tickOffset * dir + padding;
                t._setVertices([
                    [cb[i].x, pos],
                    [cb[i].x, pos + dir * this._tickSize]
                ]);
                t._updateBounds();
            }
        } else if (this._channel == "y"){
            let dir = this._orientation == "left" ? -1 : 1;
            let padding = this._orientation === "left" ? this._padding : - this._padding;
            for (let [i, t] of this._ticks.children.entries()) {
                // let xPos = this._posArg ? cb[i][this._orientation] + this._posArg - cb[0][this._orientation] + this._tickOffset * dir : 
                //                 cb[i][this._orientation] + this._tickOffset * dir,
                let xPos = this._posArg ? cb[i][this._orientation] + this._posArg - cb[0][this._orientation] + this._tickOffset * dir : 
                                    this._mlayout.group.bounds[this._orientation] + this._tickOffset * dir - padding,
                    yPos = this._tickAnchor == "middle" ? cb[i].y : cb[i][this._tickAnchor];
                t._setVertices([
                    [xPos, yPos],
                    [xPos + dir * this._tickSize, yPos]
                ]);
                t._updateBounds();
            }
        }
        this._ticks._updateBounds();
        this._updateBounds();
    }

    _positionLabels(){
        let cb = this._mlayout.cellBounds;
        if (this._channel == "x") {
            let anchor = this._orientation == "bottom" ? ["center", "top"] : ["center", "bottom"],
                offset = this._orientation == "bottom" ? this._labelOffset : -this._labelOffset;
            let padding = this._orientation === "bottom" ? this._padding : - this._padding;
            for (let [i, l] of this._labels.children.entries()) {
                l.x = cb[i].x;
                l.y = this._posArg ? cb[i][this._orientation] + this._posArg - cb[0][this._orientation] + offset : 
                                cb[i][this._orientation] + offset + padding;
                l.anchor = anchor;
                if (this._labelRotation){
                    l._rotate = [this._labelRotation, l.x, l.y];
                    l.anchor = ["right", anchor[1]];
                }
                    
            }
        } else if (this._channel == "y"){
            let anchor = this._orientation == "left" ? ["right", "middle"] : ["left", "middle"],
                offset = this._orientation == "left" ? - this._labelOffset : this._labelOffset;
            let padding = this._orientation === "left" ? this._padding : - this._padding;
            for (let [i, l] of this._labels.children.entries()) {
                // l.x = this._posArg ? cb[i][this._orientation] + this._posArg - cb[0][this._orientation] + offset 
                //             : cb[i][this._orientation] + offset;
                l.x = this._posArg ? cb[i][this._orientation] + this._posArg - cb[0][this._orientation] + offset 
                            : this._mlayout.group.bounds[this._orientation] + offset - padding;
                l.y = this._tickAnchor == "middle" ? cb[i].y : cb[i][this._tickAnchor];
                l.anchor = anchor;
                if (this._labelRotation) {
                    l._rotate = [this._labelRotation, l.x, l.y];
                }
            }
        }
        this._labels._updateBounds();
        this._updateBounds();
    }

    _positionTitle(){
        let pb = this._rules.bounds;
        this._title.achor = this._titleAnchor;
        if (!this._titlePosition) {
            if (this._channel == "x") {
                this._title.x = pb.x;
                this._titleOffset = this._labels.bounds.height + this._labelOffset + 15;
                this._title.y = this._orientation == "top" ? pb.top - this._titleOffset : pb.bottom + this._titleOffset;
            } else {
                this._titleOffset = this._labels.bounds.width + this._labelOffset + 15;
                this._title.x = this._orientation == "left" ? pb.left - this._titleOffset : pb.right + this._titleOffset;
                this._title.y = pb.y;
                if (this._rotateYTitle)
                    this._title._rotate = this._orientation == "left" ?  [-90, this._title.bounds.x, this._title.bounds.y] : [90, this._title.bounds.x, this._title.bounds.y];
            }
        } else {
            this._title.x = this._titlePosition[0];
            this._title.y = this._titlePosition[1];
            if (this._channel == "y" || this._channel == "height") {
                if (this._rotateYTitle)
                    this._title._rotate = this._orientation == "left" ?  [-90, this._title.bounds.x, this._title.bounds.y] : [90, this._title.bounds.x, this._title.bounds.y];
            }
        }   
        this._title._updateBounds();
        this._updateBounds();
    }

    matches(item) {
        return sameClass(this._item, item);
        //return getEncodingKey(this._item).split("_")[0] === getEncodingKey(item).split("_")[0];
    }
}