import Group from "../composite/Group";
import { DataType, ItemType, Orientation } from "../../util/Constants";
import PointText from "../mark/PointText";
import { ItemCounter, getLeafItems, isPath, getEncodingKey } from "../../util/ItemUtil";
import LinearGradient from "../../basic/Gradient";
import DataTable from "../../data/DataTable";
import { uniqueNumbers } from "../../util/DataUtil";
import GridLayout from "../../layout/Grid";


export default class Legend extends Group {

    constructor(encoding, args) {
        super();
        this.type = ItemType.Legend;
        this.id = this.type + ItemCounter[this.type]++;
        this.encoding = encoding;
        this._textColor = ("textColor" in args) ? args["textColor"] : "#555";
        this._strokeColor = ("strokeColor" in args) ? args["strokeColor"] : "#555";
        this._fontSize = "fontSize" in args? args.fontSize: "12px";
        this._x = ("x" in args) ? args["x"] : 0;
        this._y = ("y" in args) ? args["y"] : 0;
        this._showTitle = ("showTitle" in args) ? args["showTitle"] : true;
        this._orientation = ("orientation" in args) ? args["orientation"] : Orientation.Vertical;
        
        //for categorical legend
        if (!("numCols" in args) && !("numRows" in args)) {
            if (this._orientation === Orientation.Vertical)
                this._numCols = 1;
            else
                this._numRows = 1;
        }
        else {
            this._numCols = args["numCols"];
            this._numRows = args["numRows"];
        }
        this._initialize();
    }

    toJSON(){
        let json = super.toJSON();
        if (!("args" in json))
            json.args = {};
        json.args.textColor = this._textColor;
        json.channel = this.encoding.channel;
        json.field = this.encoding.field;
        json.args.strokeColor = this._strokeColor;
        json.args.x = this._x;
        json.args.y = this._y;
        json.args.orientation = this._orientation;
        return json;
    }

    get field() {
        return this.encoding.field;
    }    

    get channel() {
        return this.encoding.channel;
    }

    get fieldType() {
        return this.encoding.datatable.getFieldType(this.field);
    }

    _initialize() {
        let scene = this.encoding.scene, f = this.encoding.field;
        switch (this.encoding.datatable.getFieldType(f)) {
            case DataType.String:
                this._createCategoricalColorLegend(scene, f);
                break;
            case DataType.Date:
            case DataType.Number:
            case DataType.Integer:
                this._createNumericalColorLegend(scene, f);
                break;
        }
        this._updateBounds();
    }

    _createNumericalColorLegend(scene, f) {
        let wd, ht;
        if (this._orientation == Orientation.Vertical) {
            wd = 15;
            ht = 300;
        } else {
            wd = 300;
            ht = 15;
        }
        let titleSize;
        if (this._showTitle){
            let title = scene.mark("text", {fillColor: this._textColor, "text": f, x: this._x + wd/2, y: this._y, "anchor": ["center", "middle"]});
            this.addChild(title);
            titleSize = 20;
        } else {
            titleSize = 0;
        }
        
        let rect = scene.mark("rect", {"top": this._y + titleSize, "left": this._x, "width": wd, "height": ht, "strokeWidth": 0, opacity: this.encoding.anyItem.opacity});
        let domain = [Math.min(...this.encoding.data), Math.max(...this.encoding.data)], mapping = this.encoding.scale.mapping;
        let gradient;
        let texts = [], ticks = [], offset = 5, tickSize = 5;
        if (mapping) {
            let values = Object.keys(mapping).map(d => parseFloat(d)).sort((a,b) => a - b);
            if (this._orientation == Orientation.Vertical) {
                gradient = new LinearGradient({x1: 0, y1: 100, x2: 0, y2: 0});
                values.forEach(d => {
                    let p = (d - domain[0])/(domain[1] - domain[0]);
                    gradient.addStop(p*100, mapping[d], 1.0);
                    let tk = scene.mark("line", {"x1": this._x + wd, "x2": this._x + wd + tickSize, "y1": this._y + ht - p * ht + titleSize, "y2": this._y + ht - p * ht+ titleSize, "strokeColor": this._strokeColor});
                    ticks.push(tk);
                    let t = scene.mark("text", {fillColor: this._textColor, "text": d.toFixed(0), x: this._x + wd + offset + tickSize, y: this._y + ht - p * ht + titleSize, "anchor": ["left", "middle"]});
                    texts.push(t);
                })
            } else {
                gradient = new LinearGradient({x1: 0, y1: 0, x2: 100, y2: 0});
                values.forEach(d => {
                    let p = (d - domain[0])/(domain[1] - domain[0]);
                    gradient.addStop(p*100, mapping[d], 1.0);
                    let tk = scene.mark("line", {"x1": this._x + p * wd, "x2": this._x + p * wd, "y1": this._y + 20 - tickSize + titleSize, "y2": this._y + ht + tickSize + titleSize, "strokeColor": this._strokeColor});
                    ticks.push(tk);
                    let t = scene.mark("text", {fillColor: this._textColor, "text": d.toFixed(0), x: this._x + p * wd, y: this._y + ht + offset + titleSize, "anchor": ["center", "top"]});
                    texts.push(t);
                })
            }
        } else {
            let domain = this.encoding.scale.domain, dt = this.encoding.datatable, ft = dt.getFieldType(f);
            let stops = [], uniqueVals = ft === DataType.Date? dt.getUniqueFieldValues(f) : uniqueNumbers(this.encoding.data);
            if (uniqueVals.length <= 10){
                stops = uniqueVals;
                stops.sort((a, b) => a - b);
            } else {
                if (ft === DataType.Date) {
                    uniqueVals.sort((a, b) => a - b);
                    for (let i = 0; i < uniqueVals.length; i+= Math.ceil(uniqueVals.length/10))
                        stops.push(uniqueVals[i]);
                } else {
                    let incr = (domain[1] - domain[0])/9;
                    for (let i = 0; i < 10; i++)
                        stops.push(domain[0] + i * incr);
                }
            }
            //determine decimal places
            let decimalPlaces = 0, interval = (stops[stops.length - 1] - stops[0])/stops.length;
            while (interval < 1) {
                interval *= 10;
                decimalPlaces++;
            }
            stops = stops.map(d => d.toFixed(decimalPlaces));
            if (this._orientation == Orientation.Vertical) {
                gradient = new LinearGradient({x1: 0, y1: 100, x2: 0, y2: 0});
                stops.forEach(d => {
                    let p = (d - domain[0])/(domain[1] - domain[0]);
                    gradient.addStop(p*100, this.encoding.scale.map(d), 1.0);
                    let tk = scene.mark("line", {"x1": this._x + wd, "x2": this._x + wd + tickSize, "y1": this._y + ht - p * ht + titleSize, "y2": this._y + ht - p * ht + titleSize, "strokeColor": this._strokeColor});
                    ticks.push(tk);
                    let t = scene.mark("text", {fillColor: this._textColor, "text": ft === DataType.Date? dt.getRawValue(f, d) : d, x: this._x + wd + offset + tickSize, y: this._y + ht - p * ht + titleSize, "anchor": ["left", "middle"]});
                    texts.push(t);
                });
            } else {
                gradient = new LinearGradient({x1: 0, y1: 0, x2: 100, y2: 0});
                stops.forEach(d => {
                    let p = (d - domain[0])/(domain[1] - domain[0]);
                    gradient.addStop(p*100, this.encoding.scale.map(d), 1.0);
                    let tk = scene.mark("line", {"x1": this._x + p * wd, "x2": this._x + p * wd, "y1": this._y + ht + titleSize, "y2": this._y + ht + tickSize + titleSize, "strokeColor": this._strokeColor});
                    ticks.push(tk);
                    let t = scene.mark("text", {fillColor: this._textColor, "text": ft === DataType.Date? dt.getRawValue(f, d) : d, x: this._x + p * wd, y: this._y + ht + offset + titleSize, "anchor": ["center", "top"]});
                    texts.push(t);
                })
            }
        }
        rect.styles.fillColor = gradient;

        this.addChild(rect);
        for (let t of texts)
            this.addChild(t);
        for (let tk of ticks)
            this.addChild(tk);
    }

    get textColor() {
        return this._textColor;
    }

    set textColor(c) {
        this._textColor = c;
        this.setTextColor(this);
    }

    get orientation() {
        return this._orientation;
    }

    set orientation(o) {
        this._orientation = o;
        this.removeAll();
        this._initialize();
    }

    setTextColor(itm) {
        if (!itm.children || itm.children.length === 0) return;
        for (let i of itm.children) {
            if (i.type === ItemType.PointText)
                i.fillColor = this._textColor;
            else if (i.children && i.children.length > 0) {
                this.setTextColor(i);
            }
        }
    }

    _createCategoricalColorLegend(scene, f) {
        let scale = this.encoding.scale;
        let dt = new DataTable(scale.domain.map(d => ({"category": d, "value": scale.map(d)})));
        let longestText = dt.getUniqueFieldValues("category").sort((a,b) => b.length - a.length)[0];
        let mark = this.encoding.anyItem;
        let sw = isPath(mark) && mark.closed ? mark.strokeWidth : 0;
        if (this._orientation === Orientation.Vertical) {
            let titleSize = 0;
            if (this._showTitle) {
                this.addChild(new PointText({fillColor: this._textColor, "fontSize": this._fontSize, "text": f, x: this._x, y: this._y, "anchor": ["left", "top"]})); 
                titleSize = parseFloat(this._fontSize) + 5;
            }
            let rect = scene.mark("rect", {"top": this._y + 2 + titleSize, "left": this._x, "width": 10, "height": 10, "strokeWidth": sw, "strokeColor": mark.strokeColor, "opacity": mark.opacity});
            let text = scene.mark("text", {text: longestText, fillColor: this._textColor, "fontSize": this._fontSize, x: this._x + 20, y: this._y + titleSize + 12 + sw, "anchor": ["left", "bottom"]});
            let glyph = scene.glyph(rect, text);
            let coll = scene.repeat(glyph, dt);
            scene.encode(text, {"channel": "text", "field": "category", "_remember": false});
            scene.encode(rect, {"channel": "fillColor", "field": "category", "_remember": false, scale: scale});
            coll.layout = new GridLayout({"numCols": this._numCols, "numRows": this._numRows});
            this.addChild(coll);
        } else {
            //do not show title for now
            let rect = scene.mark("rect", {"top": this._y, "left": this._x, "width": 10, "height": 10, "strokeWidth": sw, "strokeColor": mark.strokeColor, "opacity": this.encoding.anyItem.opacity});
            let text = scene.mark("text", {text: longestText, fillColor: this._textColor, "fontSize": this._fontSize, x: this._x + 15, y: this._y, "anchor": ["left", "top"]});
            let glyph = scene.glyph(rect, text);
            let coll = scene.repeat(glyph, dt);
            scene.encode(text, {"channel": "text", "field": "category", "_remember": false});
            scene.encode(rect, {"channel": "fillColor", "field": "category", "_remember": false, scale: scale});
            coll.layout = new GridLayout({"numCols": this._numCols, "numRows": this._numRows, "colGap": 15});
            this.addChild(coll);
        }
        
    }

    pathHitTest(x, y) {
        let items = getLeafItems(this);
        for (let i = items.length - 1; i >= 0; i--) {
            let c = items[i];
            if (isPath(c) && c.contains(x, y))
                return c;
        }
        return null;
    }

    //item is a group or a mark or a vertex or segment
    matches(item) {
        let k = getEncodingKey(item).split("_")[0],
            encodings = this.encoding.scale.encodings;
        for (let enc of encodings) {
            let classId = getEncodingKey(enc.anyItem).split("_")[0];
            if (classId === k)
                return true;
        }
        return false;
    }

    _doTranslate(dx, dy) {
        super._doTranslate(dx, dy);
        this._x += dx;
        this._y += dy;
    }

}