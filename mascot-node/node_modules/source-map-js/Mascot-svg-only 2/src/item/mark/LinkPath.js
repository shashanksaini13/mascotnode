import Rectangle from "../../basic/Rectangle";
import { ItemType } from "../../util/Constants";
import { SVGProvider } from "../../util/ItemUtil";
import Path from "./Path";

export default class LinkPath extends Path {

    constructor(args) {
        super(args);

        this.type = ItemType.Link;
        this.linkMode = "linkMode" in args ? args.linkMode : "linear";

        this.source = undefined;
        this.target = undefined;
        this.directed = "directed" in args ? args.directed : false;

        this.sourceAnchor = "sourceAnchor" in args ? args.sourceAnchor : ["center", "middle"];
        this.targetAnchor = "targetAnchor" in args ? args.targetAnchor : ["center", "middle"];
        this.sourceOffset = "sourceOffset" in args ? args.sourceOffset : [0, 0];
        this.targetOffset = "targetOffset" in args ? args.targetOffset : [0, 0];
    }


    //Implemented according to bezier curve implementation in d3
    // https://github.com/d3/d3-shape/blob/main/src/link/index.js
    radialvalue(x, y) {
        let xBar = x- Math.PI / 2;
        x = y * Math.cos(xBar);
        y = y * Math.sin(x);
        return [x, y];
    }

    bezierCurveHorizontal(x1, y1, x2, y2) {
        return `M ${x1} ${y1} C ${(x1+x2)/2} ${y1} ${x1} ${y2} ${x2} ${y2}`
    }

    bezierCurveVertical(x1, y1, x2, y2) {
        return `M ${x1} ${y1} C ${x1} ${(y1+y2)/2} ${x2} ${y1} ${x2} ${y2}`
    }

    bezierCurveRadial(x1, y1, x2, y2) {
        let r0 = this.radialvalue(x1, y1),
            r1 = this.radialvalue(x1, (y1 + y2) / 2),
            r2 = this.radialvalue(x2, y1),
            r3 = this.radialvalue(x2, y2);

        return `M ${r0[0]} ${r0[1]} C ${r1[0]} ${r1[1]} ${r2[0]} ${r2[1]} ${r3[0]} ${r3[1]}`
    }

    arc(x1, y1, x2, y2, clockwise) {
        let sx = x1, ex = x2, sy = y1, ey = y2;
        if (!this.directed && x1 > x2) {
            sx = x2;
            ex = x1;
            sy = y2;
            ey = y1;
        }
        let rx = Math.abs(sx-ex)/2,
            ry = Math.abs(sy-ey)/2,
            r = Math.max(rx, ry),
            sweep_flag = clockwise ? 1 : 0;
        return `M ${sx} ${sy} A ${r} ${r} 0 0 ${sweep_flag} ${ex} ${ey}`
    }

    _updateBounds() {
        if (this.source != undefined && this.target != undefined){
            let x1 = this.source.bounds[this.sourceAnchor[0]] + this.sourceOffset[0],
                y1 = this.source.bounds[this.sourceAnchor[1]] + this.sourceOffset[1],
                x2 = this.target.bounds[this.targetAnchor[0]] + this.targetOffset[0],
                y2 = this.target.bounds[this.targetAnchor[1]] + this.targetOffset[1];
            this._bounds = new Rectangle(Math.min(x1, x2), Math.min(y1, y2), Math.abs(x1 - x2), Math.abs(y1 - y2));
        } else {
            this._bounds = new Rectangle(0,0,0,0);
        }
    }


    getSVGPathData() {
        if (this.source === undefined || this.target === undefined)
            return "";
        let x1 = this.source.bounds[this.sourceAnchor[0]] + this.sourceOffset[0],
            y1 = this.source.bounds[this.sourceAnchor[1]] + this.sourceOffset[1],
            x2 = this.target.bounds[this.targetAnchor[0]] + this.targetOffset[0],
            y2 = this.target.bounds[this.targetAnchor[1]] + this.targetOffset[1];
        switch (this.linkMode) {
            case "curveHorizontal":
                return this.bezierCurveHorizontal(x1, y1, x2, y2);
            case "curveVertical":
                return this.bezierCurveVertical(x1, y1, x2, y2);
            case "arcClockwise":
                return this.arc(x1, y1, x2, y2, true);
            case "arcAntiClockwise":
                return this.arc(x1, y1, x2, y2, false);
            case "linear":
            default:
                return `M ${x1} ${y1} L ${x2} ${y2}`;
        }
    }

    copyPropertiesTo(target) {
        super.copyPropertiesTo(target);
        target.sourceAnchor = this.sourceAnchor.slice();
        target.targetAnchor = this.targetAnchor.slice();
        target.sourceOffset = this.sourceOffset.slice();
        target.targetOffset = this.targetOffset.slice();
        target.linkMode = this.linkMode;
    }

    getPointAt(frac) {
        const svg = SVGProvider.getSVG();
        let path = document.createElementNS("http://www.w3.org/2000/svg", 'path');
        path.setAttribute("d", this.getSVGPathData());
        svg.appendChild(path);
        let len = path.getTotalLength();
        return path.getPointAtLength(len * frac);
    }
}