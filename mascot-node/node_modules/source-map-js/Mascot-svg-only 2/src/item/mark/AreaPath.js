import Path from "./Path";
import Segment from "../Segment";
import {ItemType} from "../../util/Constants"

export default class AreaPath extends Path {
	
	constructor(args) {
		super(args);
		
		this.type = ItemType.Area;
		this.closed = true;
		this._orientation = ("orientation" in args) ? args.orientation : undefined;
		this._baseline = ("baseline" in args) ? args.baseline : undefined;

		//add last segment to close the path
		if (args && "vertices" in args)
			this.segments.push(new Segment(this.vertices[this.vertices.length-1], this.vertices[0], this, this.segmentCounter++));
	}

	get baseline() {
		return this._baseline;
	}

	set baseline(b) {
		this._baseline = b;
	}

	//this._orientation is set during densification
	get orientation() {
		return this._orientation;
	}

	set orientation(o) {
		this._orientation = o;
	}

	get firstVertexPair() {
		return [this.vertices[0], this.vertices[this.vertices.length-1]];
	}

	get width() {
		return this.vertices[this.vertices.length/2].x - this.vertices[0].x;
	}

	get height() {
		return this.vertices[this.vertices.length/2].y - this.vertices[0].y;
	}

	get left() {
		return this.vertices[0].x;
	}

	get top() {
		return this.vertices[0].y;
	}

	copyPropertiesTo(target) {
		super.copyPropertiesTo(target);
		target._baseline = this._baseline;
		target._orientation = this._orientation;
	}

	resizeArea(wd, ht) {
		let x1 = this.vertices[this.vertices.length/2].x,
			y1 = this.vertices[this.vertices.length/2].y,
			width = this.width,
			height = this.height;
		for (let v of this.vertices) {
			v.x = x1 + (wd/width) * (v.x - x1);
			v.y = y1 + (ht/height) * (v.y - y1);
		}
		this._updateBounds();
	}

	getSVGPathData() {
		return super.getSVGPathData() + " " + 'z';
	}
}