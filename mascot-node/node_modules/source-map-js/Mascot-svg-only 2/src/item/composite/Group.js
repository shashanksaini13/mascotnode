/**
* Same as group in graphical design tools 
**/

import Rectangle from "../../basic/Rectangle";
import {DataType, ItemType} from "../../util/Constants";
import {ItemCounter} from "../../util/ItemUtil";

export default class Group {
	
	constructor() {
		this.children = [];
		this._dataScope = undefined;
		this._layout = undefined;
		this.type = ItemType.Group;
		this._id = this.type + ItemCounter[this.type]++;
	}

	get id() {
		return this._id;
	}

	set id(id) {
		if (this.type === ItemType.Scene || !this.getScene())
			this._id = id;
		else {
			delete this.getScene()._itemMap[this._id];
			this._id = id;
			this.getScene()._itemMap[id] = this;
		}
	}

	contains(x, y) {
		if (!this._bounds) {
			this._updateBounds();
		}
		return this._bounds.contains(x, y);
	}

	toJSON() {
		let json = {};
		json.type = this.type;
		json.id = this.id;
		if (this._dataScope)
			json.dataScope = this._dataScope.toJSON();
		if (this.classId)
			json.classId = this.classId;
		if (this._layout)
			json.layout = this._layout.toJSON();
		if (this._bounds)
			json.bounds = this._bounds.toJSON();
		json.children = [];
		if (this.children.length > 0) { //&& this.type != ItemType.Axis
			for (let c of this.children) {
				json.children.push(c.toJSON());
			}
		}
		if (this.childrenOrder) {
			json.childrenOrder = this.childrenOrder;
		}
		return json;
	}

	addChild(c) {
		if (this.children.indexOf(c) >= 0) return;
		if (c.parent)
			c.parent.removeChild(c);
		this.children.push(c);
		c.parent = this;
	}

	addChildAt(c,index){
		if (c.parent)
			c.parent.removeChild(c);
		this.children.splice(index, 0, c);
		c.parent = this;
	}

	removeChild(c) {
		let idx = this.children.indexOf(c);
		if (idx >= 0) {
			this.children.splice(idx, 1);
			c.parent = null;
		}
	}

	removeChildAt(i) {
		this.children[i].parent = null;
		this.children.splice(i, 1);
	}

	removeAll() {
		for (let c of this.children)
			c.parent = null;
		this.children = [];
	}

	getScene() {
		let p = this;
		while (p) {
			if (p.type == ItemType.Scene)
				return p;
			else
				p = p.parent;
		}
	}

	get dataScope() {
		return this._dataScope;
	}

	set dataScope(ds) {
		this._dataScope = ds;
		if (ds === undefined) {
			for (let c of this.children) {
				c.dataScope = ds;
			}
		} else {
			for (let c of this.children) {
				if (c.dataScope)
					c.dataScope = c.dataScope.merge(ds);
				else
					c.dataScope = ds;
			}
		}
	}

	_doTranslate(dx, dy) {
		for (let child of this.children) {
			child._doTranslate(dx, dy);
		}
		this._updateBounds();
		if (this._layout) {
			if (this._layout._left !== undefined)
				this._layout._left += dx;
			if (this._layout._top !== undefined)
				this._layout._top += dy;
			if (this._layout.x !== undefined)
				this._layout.x += dx;
			if (this._layout.y !== undefined)
				this._layout.y += dy;
			//this._layout.run();
		}
		this._updateBounds();
	}

	getInternalEncodings(channel) {
		if (this.children.length == 0)
			return [];
		let item = this.children[0], scene = this.getScene();
		let encodingKeys = Object.keys(scene.encodings);
		let classIds = [];
		while(item) {
			if (item.classId && classIds.indexOf(item.classId) < 0)
				classIds.push(item.classId);
			if (item.type === ItemType.Glyph) {
				item.children.forEach(d => classIds.push(d.classId));
				break;
			} else if (item.children) {
				item = item.children[0];
			} else
				break;
		}
		let result = [];
		for (let k of encodingKeys) {
			let tokens = k.split("_");
			for (let classId of classIds) {
				if (tokens[0] == classId) {
					if (scene.encodings[k][channel])
						result.push(scene.encodings[k][channel]);
				}
			}
		}
		return result;
	}

	get firstChild() {
		return this.children[0];
	}

	get lastChild() {
		return this.children[this.children.length - 1];
	}

	set layout(l) {
		this._layout = l;
		if (l) {
			l.group = this;
			this._layout.run();
		} else {
			//check if there are position encodings and reapply them
			let xEncs = this.getInternalEncodings("x"),
				yEncs = this.getInternalEncodings("y");
			for (let e of xEncs) {
				e._map();
				e._apply();
			}
			for (let e of yEncs) {
				e._map();
				e._apply();
			}	
		}
	}

	get layout() {
		return this._layout;
	}

	get bounds() {
		if (!this._bounds) {
			this._updateBounds();
		}
		return this._bounds;
	}

	get refBounds() {
		let cRefBounds = this.children.map (d => d.refBounds);
		let left = Math.min(...cRefBounds.map(d => d.left)), top = Math.min(...cRefBounds.map(d => d.top)),
			right = Math.max(...cRefBounds.map(d => d.right)), bottom = Math.max(...cRefBounds.map(d => d.bottom));
		return new Rectangle(left, top, right - left, bottom - top);
	}

	get x() {
		return this.bounds.x;
	}

	get y() {
		return this.bounds.y;
	}

	_updateBounds() {
		if (this.children.length > 0){
			this._bounds = this.children[0].bounds.clone();
			for (let i = 1; i < this.children.length; i++) {
				if (this.children[i].visibility == "hidden")
					continue;
				this._bounds = this._bounds.union(this.children[i].bounds);
			}
			if (this._layout && this._layout.type == "grid") {
				let cellBounds = this._layout.cellBounds;
				for (let i = 0; i < cellBounds.length; i++) {
					this._bounds = this._bounds.union(cellBounds[i]);
				}
			}
		} else {
			this._bounds = new Rectangle(0, 0, 0, 0);
		}
	}

	sortChildrenByData(field, reverse, order) {
		let type = this.children[0].dataScope.getFieldType(field);
		let f; 
		switch (type) {
			case DataType.Date:
				break;
			case DataType.Number:
			case DataType.Integer:
				f = (a, b) =>  a.dataScope.aggregateNumericalField(field) - b.dataScope.aggregateNumericalField(field);
				break;
			case DataType.String:
				if (order)
					f = (a, b) => order.indexOf(a.dataScope.getFieldValue(field)) - order.indexOf(b.dataScope.getFieldValue(field));
				else
					f = (a, b) =>  (a.dataScope.getFieldValue(field) < b.dataScope.getFieldValue(field) ? -1 : 1 );
				break;
		}
		this.children.sort(f);
		if (reverse)
			this.children.reverse();
		if (this.layout)
			this.layout.run();
		this._childrenOrder = {field: field, direction: reverse ? "desc" : "asc", ranking: order};
	}

	sortChildren(channel, reverse){
		let f;
		switch (channel){
			case "x":
			case "y":
			case "width":
			case "height":
				f = (a, b) => a.bounds[channel] - b.bounds[channel];
				break;
			default:
				f = (a, b) => a[channel] - b[channel];
				break;
		}
		this.children.sort(f);
		if (reverse)
			this.children.reverse();
		if (this.layout)
			this.layout.run();
		this.childrenOrder = {channel: channel, reverse: reverse};
	}

	set visibility(v) {
		if (v == "hidden")
			this._visibility = v;
		else
			this._visibility = "visible";
		for (let c of this.children)
			c.visibility = v;
	}

	get visibility() {
		if (!this._visibility)
			return "visible";
		return this._visibility;
	}
}