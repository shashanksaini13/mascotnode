import {ItemType, Style2SVG} from "../util/Constants";
import * as d3 from 'd3';
import SVGInteractionHandler from "./SVGInteractionHandler";

export default class SVGRenderer {

	constructor(svgId) {
		this._svgId = svgId;
		this._compMap = {};
		this._decoMap = {}; 
		this._interactionHandler = new SVGInteractionHandler(this);
	}

	render(scene, params) {
		let args = params ? params : {};
		for (let k in this._decoMap) {
			this._decoMap[k].remove();
			delete this._decoMap[k];
		}
		this._removed = {};
		for (let k in this._compMap) {
			this._removed[k] = 1;
		}
		this._renderItem(scene, args);
		for (let k in this._removed) {
			this._compMap[k].remove();
			delete this._compMap[k];
		}
		if (!("visualOnly" in args)) {
			for (let i of scene._interactions)
				this._interactionHandler.processInteraction(i, scene);
		}
	}

	clear() {
		let svg = document.getElementById(this._svgId);
        while (svg.firstChild) {
			svg.firstChild.remove();
		}
		this._compMap = {};
		this._decoMap = {};
	}

	_renderItem(c, args) {
		let cid = c.id,
			parent = c.parent;
		
		let svgParent;
		if (parent && parent.id && parent.id in this._compMap) {
			svgParent = d3.select("#"+this._svgId).select("#"+parent.id);
		} else {
			svgParent = d3.select("#"+this._svgId);
		}

		if (!(cid in this._compMap)) {
			//TODO: what if the parent is not rendered? What if the hierarchy has changed?
			this._compMap[cid] = svgParent.append(this._getSVGElementType(c));
		} else {
			delete this._removed[cid];
		}

		if (c.type == ItemType.Gridlines) {
			this._compMap[cid].lower();
		}

		let el = this._compMap[cid];

		el.attr("id", cid);
		if (c.classId)
			el.attr("class", c.classId);

		if (c.type == ItemType.Scene) {
			d3.select("#"+this._svgId).style("background", c.fillColor ? c.fillColor : "#fff");
		}

		if (c.type == "vertex") {
			//TODO: render vertices
			return;
		}

		let pathTypes = [ItemType.Path, ItemType.Polygon, ItemType.Link, ItemType.Pie, ItemType.Line, ItemType.Area, ItemType.Ring, ItemType.Arc]; 
		if (pathTypes.indexOf(c.type) >= 0) {
			el.attr("d", c.getSVGPathData());
			if (!c.closed)
				el.style("fill", "none");
			if (cid.indexOf("axis") == 0) {
				el.style("shape-rendering", "crispEdges");
			}
		// } else if (c.type == ItemType.Line) {
		// 	el.attr("x1", c.vertices[0].x);
		// 	el.attr("y1", c.vertices[0].y);
		// 	el.attr("x2", c.vertices[1].x);
		// 	el.attr("y2", c.vertices[1].y);
		// 	if (cid.indexOf("axis") == 0) {
		// 		el.style("shape-rendering", "crispEdges");
		// 	}
		} else if (c.type == ItemType.Circle) {
			el.attr("cx", c.x);
			el.attr("cy", c.y);
			el.attr("r", c.radius);
		} else if (c.type == ItemType.Rect) {
			//do not use c.left, c.top, c.width, c.height as the rectangle may be flipped
			//use c.bounds
			let b = c.bounds;
			el.attr("x", b.left).attr("y", b.top).attr("width", b.width).attr("height", b.height);
		} else if (c.type == ItemType.PointText) {
			el.attr("text-anchor", this._getTextAnchor(c.anchor[0]))
				.attr("alignment-baseline", this._getTextAnchor(c.anchor[1]))
				.attr("dominant-baseline", this._getTextAnchor(c.anchor[1]))
				.text(c.text)
				.attr("x", c.x).attr("y", c.y);
		} else if (c.type == ItemType.Image) {
			el.attr("href", c.src).attr("x", c.x).attr("y", c.y).attr("width", c.width).attr("height", c.height);
		}

		// for (let a in c.attrs) {
		// 	el.attr(Attr2SVG[a], c.attrs[a]);
		// }

		for (let s in c.styles) {
			if (c.styles[s] === undefined)
				continue;
			if (s.indexOf("Color") > 0 && c.styles[s].type == ItemType.LinearGradient) {
				if (d3.select("#"+this._svgId).select("defs").empty())
					d3.select("#"+this._svgId).append("defs");
				let defs = d3.select("defs"), gradient = c.styles[s];
				if (defs.select("#" + gradient.id).empty()) {
					let grad = defs.append("linearGradient").attr("id", gradient.id);
					grad.attr("x1", gradient.x1+"%").attr("x2", gradient.x2+"%").attr("y1", gradient.y1+"%").attr("y2", gradient.y2+"%");
					for (let stop of gradient.stops)
						grad.append("stop").attr("offset", stop.offset+"%").style("stop-color", stop.color).style("stop-opacity", stop.opacity);
				}
				el.style(Style2SVG[s], "url(#" + gradient.id + ")");
			} else {
				el.style(Style2SVG[s], c.styles[s]);
			}
				
		}

		if (c._rotate)
			el.attr("transform", "rotate(" + c._rotate.join(" ") + ")");

		// render vertices if shape is defined
		if (c.vertices) {
			// let shapes = c.vertices.map(d => d.shape).filter(d => d !== undefined);
			// if (shapes.length > 0) 
			this._renderVertices(c);
		}

		// render scene bound
		if (c.type == ItemType.Collection && args && args["collectionBounds"]) {
			let b = c.bounds;
			if (c.layout && c.layout.type == "grid") {
				this._renderLayout(c);
			} else {
				if (!(c.id in this._decoMap)) {
					this._decoMap[c.id] = d3.select("#"+this._svgId).append("rect").attr("class", "deco");
				}
				this._decoMap[c.id].attr("x", b.left).attr("y", b.top)
					.attr("width", b.width).attr("height", b.height).attr("fill", "none")
					.attr("stroke", "#1ecb40").attr("stroke-width", "2px")
					.attr("stroke-dasharray", "5,5");
			}
		}

		//render text/axis bound
		// if (c.type == ItemType.PointText || c.type == ItemType.Axis) {
		// 	let id = c.id + "-box";
		// 	let b = c.bounds;
		// 	if (!(id in this._decoMap)) {
		// 		this._decoMap[id] = d3.select("#"+this._svgId).append("rect");
		// 	}
		// 	this._decoMap[id].attr("x", b.left).attr("y", b.top)
		// 		.attr("width", b.width).attr("height", b.height).attr("fill", "none")
		// 		.attr("stroke", "#1ecb40").attr("stroke-width", "1px")
		// 		.attr("stroke-dasharray", "5,5");
		// }

		if (c.children) {
			for (let child of c.children) {
				this._renderItem(child, args);
			}
		}

	}

	_renderVertices(c) {
		let id = c.id+"-vertices";
		if (!(id in this._compMap)) {
			let parent = c.parent,
				pid = parent ? parent.id : this._svgId;
			this._compMap[id] = d3.select("#"+pid).append("g").attr("id", id);
		} else {
			delete this._removed[id];
		}

		let shapes = c.vertices.map(d => d.shape).filter(d => d !== undefined);
		if (shapes.length === 0) {
			this._compMap[id].style("visible", "hidden");
			return;
		} else {
			this._compMap[id].style("visible", "visible");
		}

		let vertices = c.vertices.filter(d => d.shape !== undefined);
		for (let v of vertices) {
			let vid = id+"-"+v.id;
			if (!(vid in this._compMap)) {
				this._compMap[vid] = d3.select("#"+id).append(v.shape).attr("id", vid);
			} else if (v.shape !== this._compMap[vid].node().tagName) {
				this._compMap[vid].remove();
				this._compMap[vid] = d3.select("#"+id).append(v.shape).attr("id", vid);
				delete this._removed[vid];
			} else {
				delete this._removed[vid];
			}
			if (v.shape == "rect") {
				d3.select("#"+vid).attr("x", v.x - v.width/2).attr("y", v.y - v.height/2)
					.attr("width", v.width).attr("height", v.height);
			} else if (v.shape == "circle") {
				d3.select("#"+vid).attr("cx", v.x).attr("cy", v.y).attr("r", v.radius);
			}
			d3.select("#"+vid).style("fill", v.fillColor).style("opacity", v.opacity)
				.style("stroke-width", v.strokeWidth).style("stroke", v.strokeColor);
		}
	}

	_renderLayout(c) {
		let gridId = c.id+"-grid";
		if (!(gridId in this._decoMap)) {
			this._decoMap[gridId] = d3.select("#"+this._svgId).append("g")
				.attr("id", gridId).attr("class", "deco");
		}
		let cellBounds = c.layout.cellBounds, rowGap = c.layout.rowGap;
		this._decoMap[gridId].selectAll("rect").remove();
		this._decoMap[gridId].selectAll("rect").data(cellBounds.slice(0, cellBounds.length -1))
			.enter().append("rect").attr("x", d => d.left).attr("y", d => d.bottom)
				.attr("width", d => d.width).attr("height", rowGap)
				.style("fill", "pink").style("opacity", 0.5)
				;
		for (let cb of cellBounds) {
			this._decoMap[gridId].append("rect").attr("x", cb.left).attr("y", cb.top)
			.attr("width", cb.width).attr("height", cb.height)
			.attr("stroke", "blue").attr("stroke-width", "1px")
			.attr("stroke-dasharray", "5,5").attr("fill", "none");
		}
		// let left = Math.min(...cellBounds.map(d => d.left)),
		// 	top = Math.min(...cellBounds.map(d => d.top))
		// this._decoMap[gridId].append("rect").attr("x", left).attr("y", top)
		// 	.attr("width", c.bounds.width).attr("height", c.bounds.height)
		// 	.attr("stroke", "blue").attr("stroke-width", "1px")
		// 	.attr("stroke-dasharray", "5,5").attr("fill", "none");

	}

	_getTextAnchor(anchor) {
		switch(anchor) {
            case "top":
                return "text-before-edge";
				//return "hanging";
            case "bottom":
				//return "text-after-edge";
				return "auto";
			case "left":
				return "start";
			case "right":
				return "end";
			case "center":
				return "middle";
			case "middle":
				return "middle";
			default:
				return anchor;
        }
	}

	_getSVGElementType(cpnt) {
		switch (cpnt.type) {
			case ItemType.Rect:
				return "rect";
			case ItemType.Collection:
			case ItemType.Group:
			case ItemType.Glyph:
			case ItemType.Scene:
			case ItemType.Axis:
			case ItemType.Legend:
			case ItemType.Gridlines:
				return "g";
			case ItemType.Area:
			case ItemType.Path:
			case ItemType.Polygon:
			case ItemType.Ring:
			case ItemType.Pie:
			case ItemType.Arc:
			case ItemType.Link:
			case ItemType.Line:
				return "path";
			case ItemType.Circle:
				return "circle";
				//return "line";
			case ItemType.PointText:
				return "text";
			case "vertex":
				if (cpnt.shape == "circle")
					return "circle";
				else if (cpnt.shape == "rect")
					return "rect";
				else throw "argument exception";
			case "image":
				return "image";
			default:
				break;
		}
	}
}