import Scale from "../core/Scale";
import {DataType, ItemType, LayoutType} from "../util/Constants";
import { uniqueNumbers } from "../util/DataUtil";

export function bindToSize(encoding){

	encoding._query = function() {
		this.data = [];		
		let field = this.field, items = this.items, aggregator = this.aggregator;
		switch (this.datatable.getFieldType(field)) {
			case DataType.Boolean:
				break;

			case DataType.Date:
				this.data = items.map(d => d.dataScope.getFieldValue(field));
				break;

			case DataType.String:
				break;

			default: //integer or number
				this.data = items.map(d => d.dataScope.aggregateNumericalField(field, aggregator));	
				break;
		}
	}

	encoding._map = function() {
		let items = this.items, data = this.data, channel = this.channel, scale;
		
		scale = new Scale(this.scaleType);

		if (this.data.find(d => d < 0) != undefined && (channel == "width" || channel == "height") && items[0].type.indexOf("rect") == 0) {
			this._rectNegativeValues = true;
			scale.domain = [Math.min(...data), Math.max(...data)];
			if (channel == "width") {
				// let left = Math.min(...(items.map(d => d.bounds.left))),
				// 	right = Math.max(...(items.map(d => d.bounds.right)));
				// scale._setRange([0, right - left]);

				//TODO: check if item width has already been encoded with a different field
				//the code below assumes width hasn't been bound to data
				scale._setRange([0, this.rangeExtent ? this.rangeExtent : Math.max(...(items.map(d => d.width)))]);
			} else {
				// let top = Math.min(...(items.map(d => d.bounds.top))),
				// 	bottom = Math.max(...(items.map(d => d.bounds.bottom)));
				// scale._setRange([0, bottom - top]);

				//TODO: check if item height has already been encoded with a different field
				//the code below assumes height hasn't been bound to data
				scale._setRange([0, this.rangeExtent ? this.rangeExtent : Math.max(...(items.map(d => d.height)))]);
			}
		} else {
			scale.domain = [0, Math.max(...data)];
			let min, max;
			if (channel == "radius" || channel == "outerRadius" || channel == "innerRadius") {
				min = 0;
				max = Math.max(...(items.map(d => d[channel])));
				if (max < 20)	max = 20;
			} else if (channel == "area") {
				min = 0;
				max = Math.max(...(items.map(d => d.bounds.width * d.bounds.height)));
				if (max < 400)	max = 400;
			} else if (channel == "fontSize") {
				min = 2;
				max = Math.max(...(items.map(d => parseFloat(d.styles.fontSize))));
			} else if (channel == "strokeWidth") {
				min = 1;
				max = Math.max(...(items.map(d => parseFloat(d.styles.strokeWidth))));
				if (max == min)
					max = min + 5;
			}  else {
				min = 0;
				max = Math.max(...(items.map(d => d.bounds[channel])));
			}
			if (this.rangeExtent)
				max = min + this.rangeExtent;
			if (this.range) {
				min = this.range[0];
				max = this.range[1];
			}
			scale._setRange([min, max]);
		}

		if (this.scale){
			// TODO	
		} else {
			this.scale = scale;
		}

		this.scale._addEncoding(this);
	}

	encoding._apply = function() {
		if (this.channel == "radius" || this.channel == "outerRadius" || this.channel == "innerRadius") {
			for (let i = 0; i < this.items.length; i++) {
				let peer = this.items[i];
				peer[this.channel] = this.scale.map(this.data[i]);
			}
			this.scene._relayoutAncestors(this.anyItem, this.items);
		} else if (this._rectNegativeValues){
			let dMax = Math.max(...this.data), dMin = Math.min(...this.data),
				base = this.channel === "width" ? Math.min(...this.items.map(d => d.bounds.left)) : 
							Math.min(...this.items.map(d => d.bounds.top)) + this.scale.rangeExtent,
				maxSide = this.channel === "width" ? "right" : "top",
				minSide = this.channel === "width" ? "left" : "bottom";
			for (let i = 0; i < this.items.length; i++) {
				let offset, peer = this.items[i];
				if (peer.parent && peer.parent.type === ItemType.Collection) {
					let pp = peer.parent.parent;
					if (pp.type === ItemType.Collection && pp.layout && pp.layout.type === LayoutType.Grid) {
						let idx = pp.children.indexOf(peer.parent);
						offset = pp.layout.cellBounds[idx][minSide];
					} else {
						offset = peer.parent.refBounds[minSide];
					}
				} else {
					offset = base;
				}
				if (this.channel === "width") {
					peer.leftSegment._doTranslate(offset + this.scale.map(0) - peer.leftSegment.vertex1.x, 0);
					peer.rightSegment._doTranslate(offset + this.scale.map(this.data[i]) -  peer.rightSegment.vertex1.x, 0);
				} else {
					peer.topSegment._doTranslate(0, offset - this.scale.map(this.data[i]) - peer.topSegment.vertex1.y);
					peer.bottomSegment._doTranslate(0, offset - this.scale.map(0) - peer.bottomSegment.vertex1.y);
				}

				peer._updateBounds();
				if (this.data[i] > 0) {
					peer.boundsOffsets[maxSide] = this.scale.map(dMax) - this.scale.map(this.data[i]);
					peer.boundsOffsets[minSide] = this.scale.map(0) - this.scale.map(dMin);
				} else {
					peer.boundsOffsets[minSide] = this.scale.map(this.data[i]) - this.scale.map(dMin);
					peer.boundsOffsets[maxSide] = this.scale.map(dMax) - this.scale.map(0);
				}
			}


			// if (this.channel == "width") {
			// 	let base = Math.min(...this.items.map(d => d.bounds.left));
			// 	for (let i = 0; i < this.items.length; i++) {
			// 		let offset, peer = this.items[i], left = peer.leftSegment.vertex1.x, right = peer.rightSegment.vertex1.x;
			// 		if (peer.parent && peer.parent.type == ItemType.Collection) {
			// 			offset = peer.parent.bounds.left;
			// 		} else {
			// 			offset = base;
			// 		}
			// 		peer.rightSegment._doTranslate(offset + this.scale.map(this.data[i]) - right, 0);
			// 		peer.leftSegment._doTranslate(offset + this.scale.map(0) - left, 0);
			// 		peer._updateBounds();
			// 		if (this.data[i] > 0) {
			// 			peer.boundsOffsets.right = this.scale.map(dMax) - this.scale.map(this.data[i]);
			// 			peer.boundsOffsets.left = this.scale.map(0) - this.scale.map(dMin);
			// 		} else {
			// 			peer.boundsOffsets.left = this.scale.map(this.data[i]) - this.scale.map(dMin);
			// 			peer.boundsOffsets.right = this.scale.map(dMax) - this.scale.map(0);
			// 		}
			// 	}
			// } else if (this.channel == "height") {
			// 	for (let i = 0; i < this.items.length; i++) {
			// 		let offset, peer = this.items[i], top = peer.topSegment.vertex1.y, btm = peer.bottomSegment.vertex1.y;
			// 		if (peer.parent && peer.parent.type === ItemType.Collection) {
			// 			let pp = peer.parent.parent;
			// 			if (pp.type === ItemType.Collection && pp.layout && pp.layout.type === LayoutType.Grid) {
			// 				let idx = pp.children.indexOf(peer.parent);
			// 				offset = pp.layout.cellBounds[idx].bottom;
			// 			} else {
			// 				offset = peer.parent.refBounds.bottom;
			// 			}
			// 		} else {
			// 			let base = Math.min(...this.items.map(d => d.bounds.top)) + this.scale.rangeExtent;
			// 			offset = base;
			// 		}
			// 		peer.topSegment._doTranslate(0, offset - this.scale.map(this.data[i]) - top);
			// 		peer.bottomSegment._doTranslate(0, offset - this.scale.map(0) - btm);
			// 		peer._updateBounds();
			// 		if (this.data[i] > 0) {
			// 			peer.boundsOffsets.top = this.scale.map(dMax) - this.scale.map(this.data[i]);
			// 			peer.boundsOffsets.bottom = this.scale.map(0) - this.scale.map(dMin);
			// 		} else {
			// 			peer.boundsOffsets.bottom = this.scale.map(this.data[i]) - this.scale.map(dMin);
			// 			peer.boundsOffsets.top = this.scale.map(dMax) - this.scale.map(0);
			// 		}
			// 	}
			// }
		} else if (this.channel == "area") {
			for (let i = 0; i < this.items.length; i++) {
				let peer = this.items[i], s = Math.sqrt(this.scale.map(this.data[i]));
				peer.resize(s, s);
			}
			this.scene._relayoutAncestors(this.anyItem, this.items);
		} else if (this.channel == "fontSize") {
			for (let i = 0; i < this.items.length; i++) {
				let peer = this.items[i], s = this.scale.map(this.data[i]);
				peer.styles.fontSize = s+ "px";
			}
			this.scene._relayoutAncestors(this.anyItem, this.items);
		} else if (this.channel == "strokeWidth") {
			for (let i = 0; i < this.items.length; i++) {
				let peer = this.items[i], s = this.scale.map(this.data[i]);
				peer.styles.strokeWidth = s;
			}
			this.scene._relayoutAncestors(this.anyItem, this.items);
		} else {
			let xRef = 'left', yRef = 'bottom';
			//if glyph item, check alignment
			if (this.anyItem.parent && this.anyItem.parent.type == ItemType.Glyph) {
				let children = this.anyItem.parent.children;
				if (uniqueNumbers(children.map(d=>d.bounds.right)).length == 1)
					xRef = 'right';
				if (uniqueNumbers(children.map(d=>d.bounds.top)).length == 1)
					yRef = 'top';
			}
			
			if (this.anyItem.type === ItemType.Collection && this.anyItem.layout && this.anyItem.layout[this.channel]) {
				//for cases like treemap barchart, where the collection size is bound to data before dividing
				for (let i = 0; i < this.items.length; i++) {
					let peer = this.items[i], s = this.scale.map(this.data[i]);
					peer.layout[this.channel] = s;
				}
			} else {
				for (let i = 0; i < this.items.length; i++) {
					let peer = this.items[i], s = this.scale.map(this.data[i]);
					let wd = this.channel == "width" ? s : peer.bounds.width,
						ht = this.channel == "height" ? s : peer.bounds.height;
					peer.resize(wd, ht, xRef, yRef);
				}
			}
			
			this.scene._relayoutAncestors(this.anyItem, this.items);
		}
	}

	encoding.run();
	return encoding;
}