/** 
 * Binding data to thickness for arcs and rings
*/
import {DataType} from "../util/Constants";
import ArcPath from "../item/mark/ArcPath";
import Scale from "../core/Scale";

function addToTree(node, arc) {
	let itm = node.item;
	if (arc.innerRadius === itm.outerRadius && itm.sweepOver(arc)) {
		node.children.push({item: arc, children: []});
		return;
	} else if (node.children && node.children.length > 0 && arc.innerRadius > itm.outerRadius && itm.sweepOver(arc)) {
		for (let c of node.children)
			addToTree(c, arc);
	}
}

function accumulateThickness(node, offset, data, scale) {
	let itm = node.item;
	itm.innerRadius = offset;
	itm.outerRadius = offset + scale.map(data[itm.id]);
	if (node.children && node.children.length > 0) {
		for (let c of node.children) {
			accumulateThickness(c, itm.outerRadius, data, scale);
		}
	}
}

export function bindToThickness(encoding){

    encoding._query = function() {
        this.data = {};
		
		let field = this.field, items = this.items;
		let dataScopes = items.map(d => d.dataScope);

		switch (this.datatable.getFieldType(field)) {
			case DataType.Boolean:
				break;

			case DataType.Date:
				for (let i = 0; i < items.length; i++) {
					this.data[items[i].id] = dataScopes[i].getFieldValue(field);
				}
				//this.data = dataScopes.map(d => d.getFieldValue(field));
				break;

			case DataType.String:
				try {
					for (let i = 0; i < items.length; i++) {
						this.data[items[i].id] = dataScopes[i].getFieldValue(field);
					}
					//this.data = dataScopes.map(d => d.getFieldValue(field));
				} catch (error) {
					throw new Error("Cannot bind " + this.channel + " to " + field + " : " + error);
				}
				break;

			default: //integer or number
				for (let i = 0; i < items.length; i++) {
					this.data[items[i].id] = dataScopes[i].aggregateNumericalField(field, this.aggregator);
				}
				//this.data = dataScopes.map(d => d.aggregateNumericalField(field, this.aggregator));
				break;
		}
    }

    encoding._map = function() {
		let data = this.data;
		if (!this.scale){
			this.scale = new Scale(this.scaleType);
			this.scale.domain = [0, Math.max(...Object.values(data))];
			let min = 1, max = this.rangeExtent ? min + this.rangeExtent : Math.max(...(this.items.map(d => d.outerRadius)));
			this.scale._setRange([min, max]);
		}
		this.scale._addEncoding(this);
	}

	

    encoding._apply = function() {
		//sort items by centroid
		this.items.sort((a, b) => (a.innerRadius+a.outerRadius)/2 - (b.innerRadius+b.outerRadius)/2);
		let outer = Math.min(...this.items.map(d => d.innerRadius));
		let tree = {item: new ArcPath({outerRadius: outer, startAngle: 0, endAngle: 360}), children: []};
		for (let itm of this.items) {
			addToTree(tree, itm);
		}
		
		for (let node of tree.children)
			accumulateThickness(node, node.item.innerRadius, this.data, this.scale);

		// //relayout if needed
		// this.scene._relayoutAncestors(this.anyItem, this.items);
	}

    encoding.run();
	return encoding;
}
