import Scale from "../core/Scale";
import {DataType} from "../util/Constants";
import {polar2Cartesian} from "../util/ItemUtil";

export function bindToRadialDistance(encoding){

    encoding._query = function() {
        this.data = [];
		
		let field = this.field, items = this.items;
		let dataScopes = ((this.anyItem.type == "vertex" || this.anyItem.type == "segment") && !this.anyItem.dataScope) ? 
							items.map(d => d.parent.dataScope) : items.map(d => d.dataScope);

		switch (this.datatable.getFieldType(field)) {
			case DataType.Boolean:
				break;

			case DataType.Date:
				this.data = dataScopes.map(d => d.getFieldValue(field));
				break;

			case DataType.String:
				try {
					this.data = dataScopes.map(d => d.getFieldValue(field));
				} catch (error) {
					throw new Error("Cannot bind " + this.channel + " to " + field + " : " + error);
				}
				break;

			default: //integer or number
				this.data = dataScopes.map(d => d.aggregateNumericalField(field, this.aggregator));
				break;
		}
    }


    encoding._map = function() {
		let data = this.data;
		if (!this.scale){
			this.scale = new Scale("linear");
			this.scale.domain = [0, Math.max(...data)];
			this.scale._setRange([0, this.anyItem.parent.radius]);
			
		}
		this.scale._addEncoding(this);
	}

    encoding._apply = function() {
		for (let i = 0; i < this.items.length; i++) {
			let peer = this.items[i], rd = this.scale.map(this.data[i]);
            let coords = polar2Cartesian(this.anyItem.parent.x, this.anyItem.parent.y, rd, peer.polarAngle);
            peer.x = coords[0];
            peer.y = coords[1];
		}

		//relayout if needed
		this.scene._relayoutAncestors(this.anyItem, this.items);
	}

    encoding.run();
	return encoding;
}