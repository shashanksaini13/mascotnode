import Scale from "../core/Scale";
import DataScope from "../data/DataScope";
import { ItemType, nodeId } from "../util/Constants";

export function bindToLink(encoding){

    encoding._query = function() {
        let field = this.field, channel = this.channel, items = this.items;
		let dataScopes = items.map(d => d.dataScope);

        // if (channel == "source" || channel == "target") {
        //     //data are marks in the scene representing the nodes
        //     let nodeIds = dataScopes.map(d => d.getFieldValue(field));
        //     let scene = this.scene;
        //     this.data = [];
        //     for (let id of nodeIds) {
        //         let r = scene.find([{field: nodeId, value: id}]);
        //         //since we assign data scopes to collections when repeating, need to filter out collections
        //         r = r.filter(d => d.type !== ItemType.Collection);
        //         this.data.push(r[0]);
        //     }
        // } else 
        if (channel == "strokeWidth") {
            if (this.datatable.hasField(field)) {
                this.data = dataScopes.map(d => d.getFieldValue(field));
            } else if (field.startsWith("parent.") || field.startsWith("child.")) {
                let dt = this.datatable.tree.nodeTable;
                let s = field.split(".")[0], f = field.split(".")[1];
                let nodeIds = dataScopes.map(d => d.getFieldValue(s));
                this.data = nodeIds.map(d => (new DataScope(dt)).cross(nodeId, d).getFieldValue(f));
            }
        }
    }

    encoding._map = function() {
        let channel = this.channel, items = this.items;
        let scale;
        if (channel == "strokeWidth") {
            scale = new Scale(this.scaleType);
            scale.domain = [0, Math.max(...this.data)];
            let min, max;
            min = 1;
			max = Math.max(...(items.map(d => parseFloat(d.styles.strokeWidth))));
			if (max == min)
				max = min + 5;
                if (this.rangeExtent)
				max = min + this.rangeExtent;
			if (this.range) {
				min = this.range[0];
				max = this.range[1];
			}
			scale._setRange([min, max]);

            if (this.scale){	
                //TODO
            } else {
                this.scale = scale;
            }
            this.scale._addEncoding(this);
        }
        
    }

    encoding._apply = function() {  
        let channel = this.channel;
        // if (channel == "source" || channel == "target") {
        //     for (let i = 0; i < this.data.length; i++) {
        //         this.items[i][this.channel] = this.data[i];
        //         this.items[i]._updateBounds();
        //     }
        // } else 
        if (channel == "strokeWidth") {
            for (let i = 0; i < this.data.length; i++) {
                this.items[i].styles.strokeWidth = this.scale.map(this.data[i]);
            }
        }
    }

    encoding.run();
	return encoding;
}