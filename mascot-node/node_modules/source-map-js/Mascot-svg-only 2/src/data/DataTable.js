import * as d3 from "d3";
import bin from "./transform/Bin";
import {atlas_rowId, DataType, ItemType} from "../util/Constants";
import kde from "./transform/KDE";
import sort from "./transform/Sort";
import filter from "./transform/Filter";
import { ItemCounter } from "../util/ItemUtil";

export default class DataTable {

	constructor(data, url, fTypes) {	
		this.url = url;	
		//this.name = _getFileName(url);
		this.id = ItemType.DataTable + ItemCounter[ItemType.DataTable]++;
		this.data = data;
		this.rawData = JSON.parse(JSON.stringify(data));
		//remember the original date values after parsing them
		this._dateMap = new Map();
		this._fields = Object.keys(this.data[0]);
		this._newField = 0;
		if (fTypes) {
			this._fieldTypes = fTypes;
		} else {
			this._fieldTypes = {};
			for (let f of this._fields) {
				this._fieldTypes[f] = _inferType(this.data.map(d => d[f]));
				if (f.toLowerCase() == "year" && this._fieldTypes[f] == DataType.Integer)
					this._fieldTypes[f] = DataType.Date;
			}
		}
		//fix null values, cast type and summarize
		this._validate(this.data, this._fieldTypes);

		this._fieldSummaries = {};
		for (let f of this._fields) {
			this._fieldSummaries[f] = _summarize(this.data.map(d => d[f]), this._fieldTypes[f]);
		}

		//add row id
		if (this._fields.indexOf(atlas_rowId) < 0) {
			this._addField(atlas_rowId, DataType.String, this.data.map((d, i) => "r" + i));
		}
	}

	get name () {
		if (this.url)
			return _getFileName(this.url);
		else
			return this.id;
	}

	//only tracking one transform away
	set sourceDataTable(dt) {
		this._sourceDataTable = dt;
	}

	get sourceDataTable() {
		return this._sourceDataTable;
	}

	getEncodableFields(channel) {
		switch(channel) {
			case "x":
			case "y":
			case "width":
			case "height":
			case "radius":
			case "fillColor":
			case "strokeColor":
			case "text":
				return this.numericFields.concat(this.nonNumericFields);
			case "area":
			case "strokeWidth":
			default:
				return this.numericFields;
			
		}
	}

	//transform from the source table to this table
	// set transform(t) {
	// 	this._transform = t;
	// }

	// get transform() {
	// 	return this._transform;
	// }

	toJSON(){
		let json = {};
		json.data = this.rawData;
		json.fieldTypes = this._fieldTypes;
		json.url = this.url;
		json.id = this.id;
		json.sourceDataTable = this._sourceDataTable;
		json.transform = this._transform;
		json.dateMap = {};
		return json;
	}

	transformField(f, callback, newf) {
		let values = this.data.map(d => callback(d[f]));
		let type = _inferType(values);
		let name = newf ? newf : Date.now() + "_field" + this._newField++;
		this._addField(name, type, values);
		return name;
	}

	setValueOrder(field, values) {
		this._fieldSummaries[field].unique = values;
	}

	_addField(name, type, values) {
		this.data.forEach( (d, i) => d[name] = values[i]);
		this._fieldTypes[name] = type;
		this._fields.push(name);
		this._fieldSummaries[name] = _summarize(values, type);
	}

	getFieldType(f) {
		return this._fieldTypes[f];
	}

	get fields() {
		return this._fields;
	}

	getFieldSummary(f) {
		return this._fieldSummaries[f];
	}

	getFieldValues(f) {
		return this.data.map(d => d[f]);
	}

	getUniqueFieldValues(f) {
		return this._fieldSummaries[f].unique;
	}

	getRowCount() {
		return this.data.length;
	}

	hasField(f) {
		return this._fields.indexOf(f) >= 0;
	}

	//date values are parsed and stored as number of milliseconds
	parseFieldAsDate(field, format) {
		//TODO: validate field and format
		let parse = d3.timeParse(format);
		for (let row of this.data) {
			let v = row[field];
			if (v == null || v == undefined) {
				v = "";
				row[field] = (new Date(1899, 11, 31)).getTime();
			} else {
				row[field] = parse(v).getTime();
			}
			this._dateMap.set(row[field], v);
		}
		this._fieldTypes[field] = DataType.Date;
		this._fieldSummaries[field] = _summarize(this.data.map(d => d[field]), DataType.Date);
	}

	//TODO: need to return the true raw value from the input file
	getRawValue(col, v) {
		if (this.getFieldType(col) === DataType.Date)
			return this._dateMap.get(v).toString();
		else
			return v;
	}

	static get RowID() {
		return atlas_rowId;
	}

	get nonNumericFields() {
		let r = [];
		for (let f in this._fieldTypes) {
			if (this._fieldTypes[f] != DataType.Number && this._fieldTypes[f] != DataType.Integer && f != DataTable.RowID) {
				r.push(f);
			}
		}
		r.sort((a,b) => this.getUniqueFieldValues(a).length - this.getUniqueFieldValues(b).length);
		return r;
	}

	get numericFields() {
		let r = [];
		for (let f in this._fieldTypes) {
			if ((this._fieldTypes[f] === DataType.Number || this._fieldTypes[f] === DataType.Integer) && f != DataTable.RowID) {
				r.push(f);
			}
		}
		return r;
	}

	getFieldsByType(t) {
		let r = [];
		for (let f in this._fieldTypes) {
			if ((this._fieldTypes[f] === t) && f != DataTable.RowID) {
				r.push(f);
			}
		}
		return r;
	}

	transform(type, fields, params) {
		let args = params ? params : {};
		switch (type) {
			case "kde":
				return kde(this, fields, args);
			case "bin":
				return bin(this, fields, args);
			case "sort":
				return sort(this, fields, args);
			case "filter":
				return filter(this, fields);
		}
	}

	summarize(){
		for (let f of this._fields) {
			this._fieldSummaries[f] = _summarize(this.data.map(d => d[f]), this._fieldTypes[f]);
		}
	}

	_validate(data, fieldTypes) {
		//date values are parsed and stored as number of milliseconds
		for (let row of data) {
			for (let f in fieldTypes) {
				let type = fieldTypes[f], v = row[f], realv = undefined;
				if (row[f] == null || row[f] == undefined) {
					switch (type) {
						case DataType.Boolean:
							realv = false;
							break;
						case DataType.Date:
							realv = (new Date(1899, 11, 31)).getTime();
							break;
						case DataType.String:
							realv = "";
							break;
						default:
							realv = 0;
							break;
					}
				} else {
					switch (type) {
						case DataType.Boolean:
							realv = v;
							break;
						case DataType.Date:
							if (Number.isInteger(v)){ //year
								realv = (new Date(v, 0)).getTime();
							} else {
								realv = (new Date(v+"")).getTime();
							}
							this._dateMap.set(realv, v);
							break;
						case DataType.String:
							realv = v.toString();
							break;
						default:
							realv = v;
							break;
					}
				}
				row[f] = realv;
			}
		}
	}
}

function _summarize(values, type) {
	var s = {};
	switch (type) {
		case DataType.Boolean:
			s.trueCount = values.filter(d => d).length;
			s.falseCount = values.filter(d => !d).length;
			break;
		case DataType.Date:
			s.min = d3.min(values);
			s.max = d3.max(values);
			s.extent = [s.min, s.max];
			s.unique = [...new Set(values)];
			break;
		case DataType.String:
			s.unique = [...new Set(values)];
			break;
		default:
			s.min = d3.min(values);
			s.max = d3.max(values);
			s.extent = [s.min, s.max];
			s.mean = d3.mean(values);
			s.median = d3.median(values);
			s.unique = [...new Set(values)];
			break;
	}
	return s;
}

var isValidType = {
	boolean: function(x) { return x==='true' || x==='false' || x === true || x === false || toString.call(x) == '[object Boolean]'; },
	integer: function(x) { return isValidType.number(x) && (x=+x) === ~~x; },
	number: function(x) { return !isNaN(+x) && toString.call(x) != '[object Date]'; },
	// date: function(x) { return !isNaN(Date.parse(x)); },
	date: function(x) { let d = new Date(x); return d != undefined && !isNaN(d) },
	// eslint-disable-next-line no-unused-vars
	string: function(x) {return true}
}

function _inferType(values) {
	var types = Object.values(DataType);
	for (let i = 0; i < values.length; i++) {
		let v = values[i];
		if (v == null)	continue;
		for (let j = 0; j < types.length; j++) {
			if (!isValidType[types[j]](v)) {
				types.splice(j, 1);
				j -= 1;
			}
		}
		if (types.length == 1)
			return types[0];
	}
	return types[0];
}

function _getFileName(url){
	var startIndex = (url.indexOf('\\') >= 0 ? url.lastIndexOf('\\') : url.lastIndexOf('/'));
	var filename = url.substring(startIndex);
	if (filename.indexOf('\\') === 0 || filename.indexOf('/') === 0) {
		filename = filename.substring(1);
	}
	return filename;
}