import { atlas_rowId, nodeId } from "../util/Constants";
import DataScope from "./DataScope";
import DataTable from "./DataTable";

const depth = "_depth";

export default class Tree {

    constructor(data, name) {
        this._type = "tree";
        let nodeArr = [];
        let linkArr = [];

        this._nodeHash = {};

        this._traverse(data, nodeArr, linkArr);

        this._nodeTable = new DataTable(nodeArr, "nodes");
        this._linkTable = new DataTable(linkArr, "links");

        this._nodeTable.tree = this;
        this._linkTable.tree = this;
        this._data = data;
        //this.aggregateFromLeaves("value", "average");
    }

    get type() {
        return this._type;
    }

    _traverse(data, nodes, links, d = 0) {
        let node = {};
        if (!(nodeId in data))
            data[nodeId] = "n" + nodes.length;
        nodes.push(node);
        data[depth] = d;
    
        for (let k in data) {
            if (k == "children" && data[k] && data[k].length > 0) {
                for (let c of data[k]) {
                    let id = this._traverse(c, nodes, links, d + 1);
                    links.push({
                        parent: data[nodeId],
                        child: id
                    });
                }
            } else
                node[k] = data[k];
        }
        this._nodeHash[node[nodeId]] = node;
        return node[nodeId];
    }

    getParent(node) {
        let id = node[nodeId];
        let parentId;
        let links = this._linkTable["data"]
        let nodes = this._nodeTable["data"];

        for (let i in links) {
            if (links[i]["child"] == id) {
                parentId = links[i]["parent"];
                let index = nodes.findIndex(x => x[nodeId] == parentId);
                return nodes[index];
            }
        }
    }

    getChildren(node) {
        let id = node[nodeId];
        let children = [];
        let links = this._linkTable["data"]
        let nodes = this._nodeTable["data"];
        for (let i in links) {
            if (links[i]["parent"] == id) {
                let childId = links[i]["child"];
                let index = nodes.findIndex(x => x[nodeId] == childId);
                children.push(nodes[index]);
            }
        }
        return children;
    }

    getNodeDataScope(node) {
        let ds = new DataScope(this._nodeTable);
        return ds.cross(atlas_rowId, node[atlas_rowId]);
    }

    getMaxDepth() {
        return this._nodeTable["_fieldSummaries"][depth]["max"];
    }

    getRoot() {
        let nodes = this._nodeTable["data"];
        return nodes[0]; // Due to recursive appending of nodes, last one is root
    }

    get nodeTable() {
        return this._nodeTable;
    }

    get linkTable() {
        return this._linkTable;
    }

    getNode(id) {
        return this._nodeTable["data"].filter(d => d[nodeId] == id)[0];
    }

    sumLeaves(root, attr) {
        if (!root) return 0;
        let id = root[nodeId];
        let children = []
        children = this.getChildren(root);

        if (children && children.length > 0) {
            let sum = 0;
            for (let child of children) {
                sum += this.sumLeaves(child, attr);
            }
            this.getNode(id)["sum" + attr] = sum;

        } else this.getNode(id)["sum" + attr] = root[attr];
        return root["sum" + attr];

    }

    countLeaves(root, attr) {
        if (!root) return 0;
        let id = root[nodeId];
        let children = []
        children = this.getChildren(root);
        let count = 0;
        if (children && children.length > 0) {
            for (let child of children) {
                count += this.countLeaves(child, attr);
            }
        } else {
            count = 1
        }
        this.getNode(id)["count" + attr] = count;
        return root["count" + attr];

    }

    averageLeaves(root, attr) {
        if (!root) return 0;
        let id = root[nodeId];
        let children = []
        children = this.getChildren(root);
        let sum = 0;
        if (children && children.length > 0) {
            for (let child of children) {
                sum += this.averageLeaves(child, attr);
            }
            sum /= children.length;
            // this.getNode(id)["median" + attr]
            this.getNode(id)["average" + attr] = sum;
        } else this.getNode(id)["average" + attr] = root[attr];
        return root["average" + attr];
    }

    medianLeaves(root, attr) {
        if (!root) return 0;
        let id = root[nodeId];
        let children = []
        children = this.getChildren(root);
        let medianArr = [];
        if (children && children.length > 0) {
            for (let child of children) {
                medianArr.push(this.medianLeaves(child, attr));
            }
            medianArr.sort(function (a, b) {
                return a - b;
            });

            let mid = Math.floor(medianArr.length / 2);

            if (medianArr.length % 2)
                this.getNode(id)["median" + attr] = medianArr[mid];
            else
                this.getNode(id)["median" + attr] = (medianArr[mid - 1] + medianArr[mid]) / 2.0;
        } else this.getNode(id)["median" + attr] = root[attr];
        return root["median" + attr];

    }

    maxLeaves(root, attr) {
        if (!root) return 0;
        let id = root[nodeId];
        let children = []
        children = this.getChildren(root);
        let Arr = [];
        if (children && children.length > 0) {
            for (let child of children) {
                Arr.push(this.maxLeaves(child, attr));
            }

            this.getNode(id)["max" + attr] = Math.max(...Arr);
        } else this.getNode(id)["max" + attr] = root[attr];

        return root["max" + attr];
    }

    minLeaves(root, attr) {
        if (!root) return 0;
        let id = root[nodeId];
        let children = []
        children = this.getChildren(root);
        let Arr = [];
        if (children && children.length > 0) {
            for (let child of children) {
                Arr.push(this.minLeaves(child, attr));
            }

            this.getNode(id)["min" + attr] = Math.min(...Arr);
        } else this.getNode(id)["min" + attr] = root[attr];
        return root["min" + attr];

    }

    aggregateFromLeaves(attr, aggregator) {
        let root = this.getRoot()
        switch (aggregator) {

            case "sum":
                this.sumLeaves(root, attr);
                break;

            case "count":
                this.countLeaves(root, attr);
                break;

            case "average":
                this.averageLeaves(root, attr);
                break;

            case "median":
                this.medianLeaves(root, attr);
                break;

            case "max":
                this.maxLeaves(root, attr);
                break;

            case "min":
                this.minLeaves(root, attr);
        }
    }

}