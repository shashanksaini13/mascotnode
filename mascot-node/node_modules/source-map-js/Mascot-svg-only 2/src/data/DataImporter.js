import * as d3 from "d3";
import DataTable from "./DataTable";
import Tree from "./Tree";
import Network from "./Network";

function makeRequest(method, url){
	return new Promise(function(resolve, reject){
		let xhr = new XMLHttpRequest();
		xhr.open(method, url);
		xhr.onload = function() {
			if (this.status >= 200 && this.status < 300) {
				resolve(xhr.response);
			} else {
				reject({
					status: this.status,
					statusText: xhr.statusText
				});
			}
		};
		xhr.onerror = function() {
			reject({
				status: this.status,
				statusText: xhr.statusText
			});
		}
		xhr.send();
	});
}

export async function importCSV(url) {
	let data = await makeRequest("GET", url);
	let parsed = d3.csvParse(data.trim(), d3.autoType);
	return new DataTable(parsed, url);
}

export async function importTreejson(url) {
	let data = await makeRequest("GET", url);
	return new Tree(JSON.parse(data), url);
}

export async function importGraphjson(url) {
	let data = await makeRequest("GET", url);
	return new Network(JSON.parse(data), url);
}

function validResponse(request) {
	var type = request.responseType;
	return type && type !== 'text' ?
		request.response : // null on error
		request.responseText; // '' on error
}

export function csvSync(url, callback) {
	let async = callback? true : false;
	var request = new XMLHttpRequest();
	request.open('GET', url, async);
	request.send();
	if (!async && validResponse(request)) {
		let data = d3.csvParse(request.responseText.trim(), d3.autoType);
		return new DataTable(data, url);
	} else {
		//TODO: throw errors based on response
	}
}