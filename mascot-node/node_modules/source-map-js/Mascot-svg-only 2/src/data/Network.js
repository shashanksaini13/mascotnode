import DataTable from "./DataTable";
import { nodeId } from "../util/Constants";
import partition from "./transform/partition";

export default class Network {

    constructor(data, name) {
        this._type = "network";
        this._nodeTable = new DataTable(data["nodes"], "nodes");
        this._linkTable = new DataTable(data["links"], "links");
        this._nodeTable.graph = this;
        this._linkTable.graph = this;
        this._nodes = data["nodes"];
        this._links = data["links"];
        this._name = name;
        this._nodeHash = {};
        for (let n of data["nodes"]){
            this._nodeHash[n[nodeId]] = n;
        }
    }

    get type() {
        return this._type;
    }

    get nodeTable() {
        return this._nodeTable;
    }

    get linkTable() {
        return this._linkTable;
    }

    get nodes() {
        return this._nodes;
    }

    get links() {
        return this._links;
    }

    getNode(id) {
        return this._nodeHash[id];
    } 

    getSources(node) {
        let id = node[nodeId];
        let links = this._links["data"];
        let nodes = this._nodes["data"];
        let sources = [];
        let sourceId;

        for (let i in links) {
            if (links[i]["target"] == id) {
                sourceId = links[i]["source"]; // Get the index of source node
                let index = nodes.findIndex(x => x[nodeId] === sourceId);
                sources.push(nodes[index]);
            }
        }
        return sources;
    }

    getTargets(node) {
        let id = node[nodeId];
        let links = this._links["data"];
        let nodes = this._nodes["data"];
        let targets = [];
        let targetId;

        for (let i in links) {
            if (links[i]["source"] == id) {
                targetId = links[i]["target"];
                let index = nodes.findIndex(x => x[nodeId] === targetId);
                targets.push(nodes[index]);
            }
        }
        return targets;
    }

    transform(type, fields, params) {
		let args = params ? params : {};
		switch (type) {
			case "partition":
				return partition(this, fields, args);
		}
	}

    isLinear() {
        let inDeg = {}, outDeg = {};
        for (let l of this._links) {
            if (!(l.source in outDeg))
                outDeg[l.source] = 0;
            if (!(l.target in inDeg))
                inDeg[l.target] = 0;
            outDeg[l.source]++;
            inDeg[l.target]++;
        }
        for (let n in inDeg)
            if (inDeg[n] > 1)
                return false;
        for (let n in outDeg)
            if (outDeg[n] > 1)
                return false;
        return true;
    }
}