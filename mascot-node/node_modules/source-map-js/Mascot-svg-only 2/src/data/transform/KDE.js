import * as d3 from "d3";
import { DataType } from "../../util/Constants";
import DataTable from "../DataTable";

export default function kde(table, fields, args) {
	//right now only handles one field
    let f = fields[0];
    //TODO: check that can perform kde on f
    let gf = table.nonNumericFields;

    let g = {};
    for (let row of table.data){
        let k = gf.map(d => String(row[d])).join("_");
        if (!(k in g)){
            g[k] = gf.map(d => row[d]);
            g[k].push([]);
        }  
        g[k][g[k].length -1].push(row[f]);
    }
    
    let min = ("min" in args) ? args.min : table.getFieldSummary(f).min,
        max = ("max" in args) ? args.max : table.getFieldSummary(f).max;
    let v = min, thresholds = [];
    while(v < max) {
        thresholds.push(v);
        v += args["interval"];
    }
    thresholds.push(v);

    let newData = [];
    for (let k in g) {
        let data = g[k].pop(), 
            density = _kde(_epanechnikov(args.bandwidth), thresholds, data);
        for (let t of density) {
            let o = {};
            g[k].forEach((d, i) => o[gf[i]] = d);
            o[f] = t[0];
            o[f+"_density"] = t[1];
            newData.push(o);
        }
    }

    let fTypes = {};
    gf.forEach(d => fTypes[d] = table.getFieldType(d));
    fTypes[f] = DataType.Number;
    fTypes[f+"_density"] = DataType.Number;

    return new DataTable(newData, table.url, fTypes);
}

function _kde(kernel, thresholds, data) {
    return thresholds.map(t => [t, d3.mean(data, d => kernel(t - d))]);
}

function _epanechnikov(bandwidth) {
    return x => Math.abs(x /= bandwidth) <= 1 ? 0.75 * (1 - x * x) / bandwidth : 0;
}

