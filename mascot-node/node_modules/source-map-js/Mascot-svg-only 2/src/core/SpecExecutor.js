import { importCSV } from "../data/DataImporter";
import Scene from "../item/composite/Scene";
import { ConstraintType } from "../util/Constants";
import { getLayout } from "../util/ItemUtil";
import Scale from "./Scale";

export default class SpecExecutor {

    constructor() {
        
    }

    async run(spec) {
        let scn;
        let itmHash = {}, dataHash = {}, scales = {};
        let data;
        // console.log("spec");
        for (let c of spec) {
            //console.log(c);
            switch (c.cmd) {
                case "scene":
                    scn = new Scene(c.args);
                    break;
                case "data":
                    data = await importCSV(c.url);
                    dataHash[c.output] = data;
                    break;
                case "transform":
                    dataHash[c.output] = dataHash[c.input].transform(c.type, c.args);
                    break;
                case "mark":
                    itmHash[c.output] = scn.mark(c.type, c.args);
                    break;
                case "glyph":
                    itmHash[c.output] = scn.glyph(...c.input.map(d => itmHash[d]));
                    break;
                case "attach":
                    scn.attach(itmHash[c.input], dataHash[c.data]);
                    break;
                case "repeat": {
                    let coll = scn.repeat(itmHash[c.input], dataHash[c.data], c.args);
                    itmHash[c.output] = coll;
                    break;
                }
                case "divide": {
                    let coll = scn.divide(itmHash[c.input], dataHash[c.data], c.args);
                    itmHash[c.output] = coll;
                    break;
                }
                case "layout":
                    itmHash[c.input].layout = getLayout(c.type, c.args);
                    break;
                case "sortChildren":
                    if ("field" in c.args)
                        itmHash[c.input].sortChildrenByData(c.args.field, c.args.reverse, c.args.order);
                    else if ("channel" in c.args)
                        itmHash[c.input].sortChildren(c.args.channel, c.args.reverse);
                    break;
                case "scale": {
                    let scale = new Scale(c.type);
                    scale.id = c.id;
                    scale.domain = c.type == "time" ? c.domain.map(d => new Date(d)) : c.domain;
                    scale.range = c.range;
                    scale.clamp = c.clamp;
                    scale.isFlipped = c.isFlipped;
                    if ("offset" in c)
                        scale.offset = c.offset;
                    scales[scale.id] = scale;
                    break;
                }
                case "encode": {
                    let itm, encKey = c.input;
                    if (encKey.indexOf("_v_") > 0) {
                        let idx = parseInt(encKey.split("_v_")[1]);
                        itm = itmHash[encKey.split("_v_")[0]].vertices[idx];
                    } else if (encKey.indexOf("_v") > 0) {
                        //TODO
                    } else if (encKey.indexOf("_s_") > 0) {
                        let idx = parseInt(encKey.split("_s_")[1]);
                        itm = itmHash[encKey.split("_s_")[0]].segments[idx];
                    } else if (encKey.indexOf("_s") > 0) {
                        //TODO
                    } else {
                        itm = itmHash[c.input];
                    }
                    if(c.scale && scales[c.scale])
                        c.args.scale = scales[c.scale];
                    scn.encode(itm, c.args);
                    break;
                }
                case "constraint":
                    switch (c.type) {
                        case ConstraintType.Affix:
                            scn.affix(itmHash[c.item], itmHash[c.baseItem], c.channel, c.args);
                            break;
                        case ConstraintType.Align:
                            //TODO
                            break;
                    }
                    break;
                case "axis":
                    scn.axis(c.channel, c.field, c.args);
                    break;
                case "legend":
                    scn.legend(c.channel, c.field, c.args);
                    break;
                case "gridlines":
                    scn.gridlines(c.channel, c.field, c.args);
            }
        }
        return scn;
    }
}