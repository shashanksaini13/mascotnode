import * as d3 from 'd3';
import { Errors, ScaleType, Warnings } from '../util/Constants';
import { ItemCounter } from '../util/ItemUtil';
import SceneValidator from './SceneValidator';


export default class Scale {

	constructor(type, args) {
		if (ScaleType.indexOf(type) < 0) {
			throw new Error(Errors.UNKOWNN_SCALE_TYPE + ": " + type);
		}
		this._type = type;
		//offset in terms of absolute coordinates on screen, this property is useful for reusing scales on items that are not in a layout
		this._offset = undefined;
		this.id = "scale" + ItemCounter["scale"]++;
		this._flipped = false;
		this._includeZero = false;
		switch (type) {
			case "linear":
				if (args) {
					//mapping
					let domain = Object.keys(args).map(d => parseFloat(d)).sort((a,b) => a - b),
						range = domain.map(d => args[d]);
					this._scale = d3.scaleLinear(domain, range);
					if ("clamp" in args)
						this._scale.clamp(args.clamp);
					this._mapping = args;
				} else {
					this._scale = d3.scaleLinear();
				}
				break;
			case "point":
				this._scale = d3.scalePoint();
				break;
			case "ordinal":
				this._scale = d3.scaleOrdinal();
				break;
			case "ordinalColor":
				this._scale = d3.scaleOrdinal(args? args.size ? d3[args.scheme][args.size] : d3[args.scheme] : d3.schemeCategory10);
				break;
			case "power":
				this._scale = d3.scalePow().exponent(2);
				break;
			case "sqrt":
				this._scale = d3.scalePow().exponent(0.5);
				break;
			case "log":
				this._scale = d3.scaleLog();
				break;
			case "identity":
			case "time":
				this._scale = d3.scaleTime();
				break;
			case "sequentialColor":
			case "divergingColor":
				if (args && typeof(args) == "string") {
					this._scale = d3.scaleSequential(d3[args]);
					this._scheme = args;
				}
				else
					this._scale = d3.scaleSequential();
				break;
			default:
				break;
		}
		this.encodings = [];
	}

	set scheme(s) {
		if (this._type.indexOf("Color") < 0 && this._type !== "linear") return;
		//TODO: need to verify the scheme is compatible with the data type and characteristics
		let scale = d3.scaleSequential(d3[s]), domain = this._scale.domain();
		if (Math.min(...domain) * Math.max(...domain) < 0) {
			let abs = Math.max(Math.abs(Math.min(...domain)), Math.abs(Math.max(...domain)));
			domain = [-abs, abs];
		} 
		scale.domain(domain);
		this._scheme = s;
		this._scale = scale;
		if (this._type === "linear") {
			this._type = this._scale.domain()[0] * this._scale.domain()[1] < 0 ? "divergingColor" : "sequentialColor";
			if (this._mapping)
				this._mapping = undefined;
		}
		for (let enc of this.encodings) {
			if (enc._mapping)
				enc._mapping = undefined;
			enc._scheme = s;
			enc._apply();
		}
	}

	get scheme() {
		return this._scheme;
	}

	get type() {
		return this._type;
	}

	set type(t) {
		let scale;
		switch (t) {
			case "linear":
				scale = d3.scaleLinear();
				break;
			case "power":
				scale = d3.scalePow().exponent(2);
				break;
			case "sqrt":
				scale = d3.scalePow().exponent(0.5);
				break;
			case "log":
				scale = d3.scaleLog();
				break;
			default:
				break;
		}
		if (scale) {
			this._type = t;
			scale.domain(this._scale.domain()).range(this._scale.range());
			this._scale = scale;
			for (let enc of this.encodings) {
				//enc._map();
				enc._apply();
			}
			for (let enc of this.encodings) {
				enc.scene._updateAncestorBounds(enc.item, enc.items);
			}
		} else {
			console.warn(Warnings.UNSUPPORTED_SCALE_TYPE_CHANGE + t);
		}
	}

	toJSON() {
		let json = {};
		json.type = this.type;
		json.id = this.id;
		json.offset = this._offset;
		if (this._scheme)
			json.scheme = this._scheme;
		json.domain = this._scale.domain();
		json.range = this.range;
		json.clamp = this.clamp;
		json.isFlipped = this.isFlipped;
		json.includeZero = this.includeZero;
		
		if (this._mapping)
			json.mapping = this._mapping;
		if (this._baseItem)
			json.baseItem = this._baseItem.id;
		return json;
	}

	// static mergeDomain(d1, d2){
	// 	return [Math.min(d1[0], d2[0]), Math.max(d1[1], d2[1])];
	// }

	//the argument s will be discarded, this scale will kept being used
	//only internally used in encoding._map
	_merge(s) {
		if (this.type != s.type) {
			throw Errors.DIFFERENT_SCALE_TYPE;
		}
		//let scale;
		let newDomain, newRange;
		switch (this.type) {
			case "linear":
			case "time":
				newDomain = [Math.min(this.domain[0], s.domain[0]), Math.max(this.domain[1], s.domain[1])];
				newRange = [0, this.map(newDomain[1]) - this.map(newDomain[0])];
				break;
			case "point":
			case "ordinalColor":
				newDomain = [...new Set(this.domain.concat(s.domain))];
				//TODO: need to compute new range
				newRange = [];
				//scale = createScale("point");
				//scale.domain = [...new Set(this.domain.concat(s.domain))];
				break;
			default:
				console.log("TODO: merge scale type", this.type);
				break;
		}
		this._scale.domain(newDomain);
		this._scale.range(newRange);
	}

	get domain() {
		//TODO: this._scale.domain contains the true data domain values,
		//this getter returns a different domain depending on includeZero
		if (this._includeZero) {
			let d = this._scale.domain();
			return [0, d[1]];
		} else
			return this._scale.domain();
	}

	set domain(d) {
		this._scale.domain(d);
		for (let enc of this.encodings) {
			//enc._map();
			enc._apply();
		}
	}

	get range() {
		return this._scale.range();
	}

	//disable setting range directly because scale ranges are internally represented as [0, extent], 
	//to support this, the argument should be in real screen coordinates and need to do internal conversion
	set range(r) {
		//TODO: check r is a two-element array
		this._scale.range(r);
		for (let enc of this.encodings) {
			//enc._map();
			enc._apply();
		}

		for (let enc of this.encodings) {
			enc.scene._updateAncestorBounds(enc.item, enc.items);
		}
	}

	_setRange(r) {
		//TODO: check r is a two-element array
		this._scale.range(r);
		SceneValidator.scaleRangeSet(this);
	}

	get clamp() {
		if (this.type == "linear")
			return this._scale.clamp();
		else
			return false;
	}

	set clamp(c) {
		if (this.type == "linear")
			this._scale.clamp(c);
	}

	set rangeExtent(e) {
		//TODO: check e is a valid number
		let r = this._scale.range();
		this._setRange([r[0], r[0] + e]);
		// if (r[0] < r[1])
		// 	this._setRange([r[0], r[0] + e]);
		// else
		// 	this._setRange([r[1] + e, r[1]]);
	}

	get rangeExtent() {
		let r = this._scale.range();
		return Math.abs(r[1] - r[0]);
	}

	_addEncoding(b) {
		if (this.encodings.indexOf(b) < 0)
			this.encodings.push(b);
	}

	map(d) {
		let s = this._scale.copy();
		s.domain(this.domain);
		if (this._flipped) {
			s.range(this._scale.range().reverse());
			return s(d);
		}
		else
			return s(d);
	}

	//TODO: handle flip
	invert(r) {
		return this._scale.invert(r);
	}

	get offset() {
		return this._offset;
	}

	set offset(s) {
		this._offset = s;
		for (let enc of this.encodings) {
			enc._apply();
		}
	}

	get isFlipped() {
		return this._flipped;
	}

	set isFlipped(f) {
		this._flipped = f;
	}

	get includeZero() {
		return this._includeZero;
	}

	set includeZero(i) {
		this._includeZero = i;
		SceneValidator.scaleDomainSet(this);
	}

	get mapping() {
		return this._mapping;
	}

	getEncodedChannels() {
		let channels = {};
		for (let enc of this.encodings) {
			channels[enc.channel] = true;
		} 
		return Object.keys(channels);
	}
}