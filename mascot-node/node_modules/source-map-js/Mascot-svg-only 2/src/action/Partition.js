import {Errors, DataType, ItemType, Orientation, Direction} from "../util/Constants";
import DataScope from "../data/DataScope";
import {getPeers} from "../util/ItemUtil";
import StackLayout from "../layout/Stack";
import { normalizeAngle } from "../util/DataUtil";

export function dividable(compnt) {
	if ([ItemType.Line, ItemType.Circle, ItemType.Rect, ItemType.Area, ItemType.Ring, ItemType.Pie, ItemType.Path].indexOf(compnt.type) < 0) {
		return false;
	} 

	if (compnt.type === ItemType.Path && (compnt.closed || !compnt.firstVertex.dataScope))
		return false;

	if (!compnt.dataScope) {
		return true;
	} else {
		let peers = getPeers(compnt, compnt.getScene());
		for (let p of peers) {
			if (p.dataScope.numTuples > 1)
				return true;
		}
		return false;
	}
}

export function divideItem(scene, compnt, orientation, field, datatable, callback) {
	let f = callback ? datatable.transformField(field, callback) : field;
	let type = datatable.getFieldType(f);

	if (type != DataType.String && type != DataType.Date) {
		throw new Error(Errors.PARTITION_BY_NONCAT + ": " + f + " is " + type);
	}

	if (!dividable(compnt)) {
		throw new Error(Errors.COMPNT_NON_PARTITIONABLE);
	}

	switch (compnt.type) {
		case ItemType.Line:
			return _doLineDivide(scene, compnt, f, datatable);
		case ItemType.Path:
			return _doPathDivide(scene, compnt, f, datatable);
		case ItemType.Circle:
			return _doCircleDivide(scene, compnt, orientation, f, datatable);
		case ItemType.Rect:
			return _doRectDivide(scene, compnt, orientation, f, datatable);
		case ItemType.Area:
			return _doAreaDivide(scene, compnt, orientation, f, datatable);
		case ItemType.Ring:
			return _doRingDivide(scene, compnt, orientation, f, datatable);
		case ItemType.Pie:
		case ItemType.Arc:
			return _doArcDivide(scene, compnt, orientation, f, datatable);
	}
	
}

function _doLineDivide(scene, compnt, field, datatable) {
	let peers = getPeers(compnt, scene);
	let colls = [], toReturn;
	let ds = datatable.getFieldSummary(field).unique.map(d => new DataScope(datatable).cross(field, d));

	let line2Scopes = {}, max = 0;
	for (let p of peers) {
		let scopes = ds;
		if (p.dataScope) {
			scopes = ds.map(d => d.merge(p.dataScope));
			scopes = scopes.filter(d => !d.isEmpty());
		}
		if (scopes.length > max)
			max = scopes.length;
		line2Scopes[p.id] = scopes;
	}
	let collClassId;
	for (let p of peers) {
		let coll = scene.collection();
		if (collClassId == undefined)
			collClassId = coll.id;
		coll.classId = collClassId;
		coll.dataScope = p.dataScope;

		let parent = p.parent;
		//let index = parent.children.indexOf(p) - 1;
		parent.addChild(coll);

		let scopes = line2Scopes[p.id];
		let x1 = p.vertices[0].x, y1 = p.vertices[0].y, x2 = p.vertices[1].x, y2 = p.vertices[1].y;

		// p.classId = compnt.id;
		// p.vertices[0].x = x1;
		// p.vertices[0].y = y1;
		// p.vertices[1].x = x1 + (x2 - x1)/max;
		// p.vertices[1].y = y1 + (y2 - y1)/max;
		// p.dataScope = scopes[0];
		// coll.addChild(p);
		
		for (let i = 0; i < scopes.length; i++) {
			let c = p.duplicate();
			c.classId = compnt.id;
			c.vertices[0].x = x1 + (x2 - x1) * i /max
			c.vertices[0].y = y1 + (y2 - y1) * i /max;
			c.vertices[1].x = x1 + (x2 - x1) * (i + 1)/max;
			c.vertices[1].y = y1 + (y2 - y1) * (i + 1)/max;
			c.dataScope = scopes[i];
			coll.addChild(c);
		}

		parent.removeChild(p);
		colls.push(coll);

		if (p == compnt)
			toReturn = coll;
	}

	return toReturn;
}

function _doPathDivide(scene, compnt, field, datatable) {
	let peers = getPeers(compnt, scene);
	let colls = [], toReturn;
	let ds = datatable.getFieldSummary(field).unique.map(d => new DataScope(datatable).cross(field, d));

	let line2Scopes = {}, max = 0;
	for (let p of peers) {
		let scopes = ds;
		if (p.dataScope) {
			scopes = ds.map(d => d.merge(p.dataScope));
			scopes = scopes.filter(d => !d.isEmpty());
		}
		if (scopes.length > max)
			max = scopes.length;
		line2Scopes[p.id] = scopes;
	}
	let collClassId;
	for (let p of peers) {
		let coll = scene.collection();
		if (collClassId == undefined)
			collClassId = coll.id;
		coll.classId = collClassId;
		coll.dataScope = p.dataScope;

		let parent = p.parent;
		//let index = parent.children.indexOf(p) - 1;
		parent.addChild(coll);

		let scopes = line2Scopes[p.id];
		let x1 = p.bounds.left, y1 = p.bounds.top, x2 = p.bounds.right, y2 = p.bounds.bottom;

		for (let i = 0; i < scopes.length; i++) {
			let c = scene.mark("line", {x1: x1 + (x2 - x1) * i /max, x2: x1 + (x2 - x1) * (i + 1)/max, y1: y1 + (y2 - y1) * i /max, y2: y1 + (y2 - y1) * (i + 1)/max});
			c.classId = compnt.id;
			c.dataScope = scopes[i];
			coll.addChild(c);
		}

		parent.removeChild(p);
		colls.push(coll);

		if (p == compnt)
			toReturn = coll;
	}

	let f = compnt.firstVertex.dataScope.fields[0];	
	scene.densify(toReturn.firstChild, datatable, {field: f});
	

	return toReturn;
}



function _doRectDivide(scene, compnt, o, field, datatable) {
	let peers = getPeers(compnt, scene);
	let colls = [], toReturn, orientation = o ? o : Orientation.Horizontal;
	if (orientation != Orientation.Horizontal && orientation != Orientation.Vertical)
		throw Errors.UNKNOWN_Orientation + ": " + orientation; 
	let ds = datatable.getFieldSummary(field).unique.map(d => new DataScope(datatable).cross(field, d));

	//datascopes
	let rect2Scopes = {}, max = 0;
	for (let p of peers) {
		let scopes = ds;
		if (p.dataScope) {
			scopes = ds.map(d => d.merge(p.dataScope));
			scopes = scopes.filter(d => !d.isEmpty());
		}
		if (scopes.length > max)
			max = scopes.length;
		rect2Scopes[p.id] = scopes;
	}

	let collClassId;
	for (let p of peers) {
		let coll = scene.collection();
		if (collClassId == undefined)
			collClassId = coll.id;
		coll.classId = collClassId;
		coll.dataScope = p.dataScope ? p.dataScope : new DataScope(datatable);

		let parent = p.parent;
		//let index = parent.children.indexOf(p) - 1;
		parent.addChild(coll);

		let scopes = rect2Scopes[p.id];
		let bounds = p.bounds, left = bounds.left, top = bounds.top;

		// let wd = orientation == Orientation.Horizontal ? bounds.width/max : bounds.width,
		// 	ht = orientation == Orientation.Horizontal ? bounds.height : bounds.height/max;
		let wd = orientation == Orientation.Horizontal ? bounds.width/scopes.length : bounds.width,
			ht = orientation == Orientation.Horizontal ? bounds.height : bounds.height/scopes.length;
		
		for (let i = 0; i < scopes.length; i++) {
			let c = p.duplicate();
			c.classId = compnt.id;
			c.resize(wd, ht);
			c.dataScope = scopes[i];
			coll.addChild(c);
		}

		coll.layout = new StackLayout({orientation: orientation, left: left, top: top});

		colls.push(coll);

		parent.removeChild(p);

		if (p == compnt)
			toReturn = coll;
	}

	scene._reapplySizeBindings(toReturn);

	return toReturn;
}

function _doAreaDivide(scene, compnt, orientation, field, datatable) {
	let peers = getPeers(compnt, scene);
	// make sure the orientation is correct; in case that the boundary partitioning has already been performed if we initial an area mark other than a rect
	let p1 = peers[0];
	if ((p1.vertices.length == 4) && (orientation == Orientation.Horizontal) && (p1.vertices[0].x !== p1.vertices[1].x)) {
		for (let p of peers) {
			let temp = p.vertices[1];
			p.vertices[1] = p.vertices[3];
			p.vertices[3] = temp;
		}
	}
	let colls = [], toReturn;
	let ds = datatable.getFieldSummary(field).unique.map(d => new DataScope(datatable).cross(field, d));
	let collClassId;
	for (let p of peers) {
		let coll = scene.collection();
		if (collClassId == undefined)
			collClassId = coll.id;
		coll.classId = collClassId;
		coll.dataScope = p.dataScope ? p.dataScope : new DataScope(datatable);

		let parent = p.parent;
		parent.addChild(coll);

		let left = p.left, top = p.top;

		let wd = orientation == Orientation.Horizontal ? p.width/ds.length : p.width,
		ht = orientation == Orientation.Horizontal ? p.height : p.height/ds.length;
		// p.classId = compnt.id;
		// p.resizeArea(wd, ht);
		// coll.addChild(p);

		for (let i = 0; i < ds.length; i++) {
			let c = p.duplicate();
			c.classId = compnt.id;
			c.resizeArea(wd, ht);
			coll.addChild(c);
		}

		parent.removeChild(p);

		for (let i = 0; i < coll.children.length; i++) {
			let child = coll.children[i];
			if (child.dataScope) {
				child.dataScope = child.dataScope.merge(ds[i]);
			} else {
				child.dataScope = ds[i];
			}
			// assigning datascope for boundary vertices
			for (let v of child.vertices){
				if (v.dataScope) {
					v.dataScope = child.dataScope.merge(v.dataScope);
				}
				else {
					v.dataScope = child.dataScope;
				}
			}
		}

		coll.layout = new StackLayout({orientation: orientation, left: left, top: top});

		colls.push(coll);

		if (p == compnt)
			toReturn = coll;
	}
	scene._reapplySizeBindings(toReturn);
	return toReturn;
}

function _doArcDivide(scene, compnt, o, field, datatable) {
	let toReturn, orientation = o ? o : Orientation.Radial;
	let peers = getPeers(compnt, scene);
	let collClassId;
	if (orientation == Orientation.Radial) {
		peers.forEach(p => {
			let pieDS = p.dataScope ? p.dataScope : new DataScope(datatable);
			let ds = datatable.getFieldSummary(field).unique.map(d => pieDS.cross(field, d));
			ds = ds.filter(d => !d.isEmpty()); 
			let numArcs = ds.length;
	
			// Define new collection and save parent
			let coll = scene.collection();
			coll.dataScope = pieDS;
			if (collClassId == undefined)
				collClassId = coll.id;
			coll.classId = collClassId;
			let parent = p.parent;
			// Create each arc
			for (let i = 0; i < numArcs; i++){
				let arc = scene.mark("arc", {
					innerRadius: i * p.outerRadius/numArcs,
					outerRadius: (i+1) * p.outerRadius/numArcs,
					x: p.x,
					y: p.y,
					startAngle: p.startAngle,
					endAngle: p.endAngle,
					strokeColor: p.strokeColor,
					fillColor: p.fillColor,
					strokeWidth: p.strokeWidth,
					opacity: p.opacity
				});

				// Add the datascope
				arc.dataScope = ds[i];
				arc.classId = compnt.id;
	
				// Add to collection
				coll.addChild(arc);
			}

			coll.layout = new StackLayout({orientation: Orientation.Radial});
	
			// Replace original circle w/ coll of pies
			parent.removeChild(p);
			parent.addChild(coll);
	
			// Return collection
			if (p == compnt)
				toReturn = coll;
		});
		return toReturn;
	} else {
		throw Errors.UNKNOWN_Orientation + ": " + orientation;
	}
}

function _doRingDivide(scene, compnt, o, field, datatable) {
	let toReturn, orientation = o ? o : Orientation.Angular;
	let peers = getPeers(compnt, scene);
	let collClassId;
	if (orientation == Orientation.Angular) {
		peers.forEach(p => {
			let ringDS = p.dataScope ? p.dataScope : new DataScope(datatable);
			let ds = datatable.getFieldSummary(field).unique.map(d => ringDS.cross(field, d));
			ds = ds.filter(d => !d.isEmpty()); 
			let numArcs = ds.length;
	
			// Define new collection and save parent
			let coll = scene.collection();
			coll.dataScope = ringDS;
			if (collClassId == undefined)
				collClassId = coll.id;
			coll.classId = collClassId;
			let parent = p.parent;
	
			let arcAng = 360 / numArcs;
	
			// Create each pie
			let start = 90;
			let clockwise = true; 
			for (let i = 0; i < numArcs; i++){
				let arc = scene.mark("arc", {
					innerRadius: p.innerRadius,
					outerRadius: p.outerRadius,
					x: p.x,
					y: p.y,
					startAngle: clockwise ? normalizeAngle(start - arcAng * (i + 1)) : normalizeAngle(start + arcAng * i),
					endAngle: clockwise ? normalizeAngle(start - arcAng * i) : normalizeAngle(start + arcAng * (i + 1)),
					strokeColor: p.strokeColor,
					fillColor: p.fillColor,
					strokeWidth: p.strokeWidth,
					opacity: p.opacity
				});

				// Add the datascope
				arc.dataScope = ds[i];
				arc.classId = compnt.id;
	
				// Add to collection
				coll.addChild(arc);
			}
			coll.layout = new StackLayout({direction: Direction.Clockwise, orientation: Orientation.Angular});
			// Replace original circle w/ coll of pies
			parent.removeChild(p);
			parent.addChild(coll);
	
			// Return collection
			if (p == compnt)
				toReturn = coll;
		});
		return toReturn;
	} else {
		throw Errors.UNKNOWN_Orientation + ": " + orientation;
	}
}


function _doCircleDivide(scene, compnt, o, field, datatable) {
	let toReturn, orientation = o ? o : Orientation.Angular;

	// Perform on all repitions of cmpnt on canvas
	let peers = getPeers(compnt, scene);
	let collClassId;
	if (orientation == Orientation.Angular) {
		peers.forEach(p => {
			let circDS = p.dataScope ? p.dataScope : new DataScope(datatable);
			//console.info("Peer DS: ", circDS);
			let ds = datatable.getFieldSummary(field).unique.map(d => circDS.cross(field, d));
			ds = ds.filter(d => !d.isEmpty()); 
			let numPies = ds.length;
	
			// Define new collection and save parent
			let coll = scene.collection();
			coll.dataScope = circDS;
			if (collClassId == undefined)
				collClassId = coll.id;
			coll.classId = collClassId;
			let parent = p.parent;
	
			// Calculate angle of each pie
			let pieAng = 360 / numPies;
	
			// Create each pie
			let start = 90;
			let clockwise = true;
			for (let i = 0; i < numPies; i++){
				let pie = scene.mark("pie", {
					innerRadius: 0,
					outerRadius: p.radius,
					x: p.x,
					y: p.y,
					startAngle: clockwise ? normalizeAngle(start - pieAng * (i + 1)) : normalizeAngle(start + pieAng * i),
					endAngle: clockwise ? normalizeAngle(start - pieAng * i) : normalizeAngle(start + pieAng * (i + 1)),
					strokeColor: p.strokeColor,
					fillColor: p.styles.fillColor 
				});

				// Add the datascope
				pie.dataScope = ds[i];
				pie.classId = compnt.id;
	
				// Add to collection
				coll.addChild(pie);
			}
	
			coll.layout = new StackLayout({orientation: Orientation.Angular, direction: Direction.Clockwise});
			// Replace original circle w/ coll of pies
			parent.removeChild(p);
			parent.addChild(coll);
	
			// Return collection
			if (p == compnt)
				toReturn = coll;
		});
	} else if (orientation == Orientation.Radial) {//radial
		peers.forEach(p => {
			let circDS = p.dataScope ? p.dataScope : new DataScope(datatable);
			let ds = datatable.getFieldSummary(field).unique.map(d => circDS.cross(field, d));
			ds = ds.filter(d => !d.isEmpty()); 
			let numRings = ds.length;
	
			// Define new collection and save parent
			let coll = scene.collection();
			coll.dataScope = circDS;
			if (collClassId == undefined)
				collClassId = coll.id;
			coll.classId = collClassId;
			let parent = p.parent;
	
			// Calculate angle of each pie
			let thickness = p.radius / numRings;
	
			// Create each pie
			for (let i = 0; i < numRings; i++){
				let r = scene.mark("ring", {
					x: p.x,
					y: p.y,
					innerRadius: i * thickness,
					outerRadius: (i + 1) * thickness,
					strokeColor: p.strokeColor,
					fillColor: p.styles.fillColor 
				})
	
				// Add the datascope
				r.dataScope = ds[i];
				r.classId = compnt.id;
	
				// Add to collection
				coll.addChild(r);
			}
	
			// Replace original circle w/ coll of pies
			parent.removeChild(p);
			parent.addChild(coll);
	
			// Return collection
			if (p == compnt)
				toReturn = coll;
		});
	} else {
		throw Errors.UNKNOWN_Orientation + ": " + orientation;
	}

	return toReturn;
}
