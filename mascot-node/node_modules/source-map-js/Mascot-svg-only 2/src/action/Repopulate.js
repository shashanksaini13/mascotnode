import DataScope from "../data/DataScope";
import { DataType, Errors } from "../util/Constants";
import { getPeers } from "../util/ItemUtil";

export function repopulateItem(scene, compnt, field, datatable) {
    let type = datatable.getFieldType(field);

	if (type != DataType.String && type != DataType.Date && type != DataType.Integer) {
		throw new Error(Errors.REPOPULATE_BY_NONCAT + ": " + field + " is " + type);
	}

    if (compnt.parent && compnt.parent.dataScope && !compnt.parent.dataScope.isFullTable() && compnt.parent.dataScope.dataTable != datatable) {
        throw new Error(Errors.REPOPULATE_DT_MISMATCH);
    }

    return _doRopulate(scene, compnt, field, datatable);
}

function _doRopulate(scene, item, field, datatable) {
    
	//assuming parent is a collection
    let peers = getPeers(item.parent, scene);
    if (peers.length === 1) {
        item.parent.dataScope = undefined;
    }
    for (let coll of peers) {
        let ds = datatable.getFieldSummary(field).unique.map(d => coll.dataScope ? coll.dataScope.cross(field, d) : new DataScope(datatable).cross(field, d));
        ds = ds.filter(d => !d.isEmpty());
        const toAdd = ds.length - coll.children.length, toRemove = coll.children.length - ds.length;
        for (let i = 0; i < toRemove; i++) {
            coll.removeChildAt(coll.children.length - 1); 
        }
        const numPeers = coll.children.length;
        for (let i = 0; i < toAdd; i++) {
            let c = coll.children[Math.floor(Math.random()*numPeers)].duplicate();
            coll.addChild(c);
        }
        coll.children.forEach((d, i) => d.dataScope = ds[i]);
    }
    scene._relayoutAncestors(item);
    

    //TODO: remove encodings;
}