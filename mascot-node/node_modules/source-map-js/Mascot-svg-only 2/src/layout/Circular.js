import {Direction, Alignment} from "../util/Constants";
import Matrix from "../basic/Matrix";
import Rectangle from "../basic/Rectangle";

/**
** Circular layout can not be applied to nested collections
** Primary use case: people garden
** For pie charts, use Partition
** For polar line graphs, area charts, weather radial etc. use Polar Transformation on a scene
**/

class CircularLayout {

	constructor(args) {
		this.type = "circular";
		this.center = args.hasOwnProperty("center") ? args["center"] : {x: 500, y:400};
		this.radius = args.hasOwnProperty("radius") ? args["radius"] : 200;
		this.startAngle = args.hasOwnProperty("startAngle") ? args["startAngle"] : 90;
		this.endAngle = args.hasOwnProperty("endAngle") ? args["endAngle"] : 450;
		this.direction = args.hasOwnProperty("direction") ? args["direction"] : Direction.Anticlockwise;
	}

	clone() {
		return new CircularLayout({
			center: {x: this.center.x, y: this.center.y},
			radius: this.radius,
			startAngle: this.startAngle,
			endAngle: this.endAngle,
			direction: this.direction
		});
	}

	run() {
		if (this.collection == undefined)
			return;

		let collection = this.collection;
		let scene = this.collection.getScene();

		let bounds = collection.children.map(d => d.unRotatedBounds);
		let wds = bounds.map(d => d.width),
			hts = bounds.map(d => d.height);
		let cellWidth = Math.max(...wds),
			cellHeight = Math.max(...hts);

		for (let i = 0; i < collection.children.length; i++) {
			let item = collection.children[i];
			let cellBounds = this._getCellBounds(item, scene, cellWidth, cellHeight);
			
			let cellCenter = cellBounds.center;
			
			let dx = this.center.x - cellCenter.x, dy = this.center.y - this.radius - cellCenter.y;
			let mx = new Matrix();
			mx._doTranslate(dx, dy);

			let angle = (this.endAngle - this.startAngle)/(collection.children.length+1);

			let mx1 = new Matrix();
			mx1.rotate(90 - (this.startAngle + angle * i), this.center);

			mx.prepend(mx1);
		  	item._matrix = mx;
		}
		this.collection._updateBounds();
	}

	//TODO: handle collections
	_getCellBounds(item, scene, cellWidth, cellHeight) {
		let left, top;
		let bounds = item.unRotatedBounds;
		switch (scene._cellAlign[item.classId].x) {
			case Alignment.Left:
				left = bounds.left;
				break;
			case Alignment.Center:
				left = bounds.center.x - cellWidth/2;
				break;
			case Alignment.Right:
				left = bounds.right - cellWidth;
				break;
		}
		switch(scene._cellAlign[item.classId].y) {
			case Alignment.Top:
				top = bounds.top;
				break;
			case Alignment.Middle:
				top = bounds.center.y - cellHeight/2;
				break;
			case Alignment.Bottom:
				top = bounds.bottom - cellHeight;
				break;
		}
		return new Rectangle(left, top, cellWidth, cellHeight);
	}
}