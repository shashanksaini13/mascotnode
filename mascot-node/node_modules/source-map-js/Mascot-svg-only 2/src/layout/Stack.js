import {Orientation, Alignment, LayoutType, Errors, ItemType, Direction} from "../util/Constants";
import { normalizeAngle } from "../util/DataUtil";
import { getLeafMarks } from "../util/ItemUtil";
import Layout from "./Layout";

export default class StackLayout extends Layout {

	constructor(args) {
		super(args);
		this.type = LayoutType.Stack;
		this._orientation = args.orientation;
		this._direction = args.direction;
		this._left = args.left;
		this._top = args.top;
		this._horzCellAlignment = "horzCellAlignment" in args && args["horzCellAlignment"] ? args.horzCellAlignment : Alignment.Left;
		this._vertCellAlignment = "vertCellAlignment" in args && args["vertCellAlignment"]  ? args.vertCellAlignment : Alignment.Bottom;
		this._gap = "gap" in args ? args.gap : 0;
	}

	toJSON() {
		let json = {args: {}};
		json.type = this.type;
		json.args.orientation = this._orientation;
		json.args.direction = this._direction;
		json.args.left = this._left;
		json.args.top = this._top;
		json.args.gap = this._gap;
		json.args.horzCellAlignment = this._horzCellAlignment;
		json.args.vertCellAlignment = this._vertCellAlignment;
		return json;
	}

	clone() {
		let s = new StackLayout({orientation: this._orientation, direction: this._direction, left: this._left, top: this._top});
		s._horzCellAlignment = this._horzCellAlignment;
		s._vertCellAlignment = this._vertCellAlignment;
		return s;
	}

	_stackAreasVert() {
		let areas = this.group.children, gb = this.group.bounds, 
			start = this._vertCellAlignment === Alignment.Top ? gb.top : gb.bottom,
			dir = this._vertCellAlignment === Alignment.Top ? 1 : -1;
		let vCnt = areas[0].vertices.length/2,
			cumuHts = new Array(vCnt).fill(0);
		for (let area of areas) {
			for (let i = 0; i < vCnt; i++) {
				let v1 = area.vertices[i],
					v2 = area.vertices[vCnt*2 - i - 1],
					ht = Math.abs(v1.y - v2.y);
				let y1 = start + cumuHts[i] * dir, y2 = start + (cumuHts[i] + ht) * dir;
				v1._doTranslate(0, y1 - v1.y);
				v2._doTranslate(0, y2 - v2.y);
				cumuHts[i] += ht;
			}
			area._updateBounds();
		}
		if (this.vertCellAlignment === Alignment.Middle) {
			for (let area of areas) {
				for (let i = 0; i < vCnt; i++) {
					let v1 = area.vertices[i],
						v2 = area.vertices[vCnt*2 - i - 1];
					let b = gb.middle + cumuHts[i]/2;
					v1._doTranslate(0, b - gb.bottom);
					v2._doTranslate(0, b - gb.bottom);
				}
				area._updateBounds();
			}
		}
		this.group._updateBounds();
	}

	_stackAreasHorz() {
		let areas = this.group.children, gb = this.group.bounds, 
			start = this._horzCellAlignment === Alignment.Right ? gb.right : gb.left,
			dir = this._horzCellAlignment === Alignment.Right ? -1 : 1;
		let vCnt = areas[0].vertices.length/2,
			cumuWds = new Array(vCnt).fill(0);
		for (let area of areas) {
			for (let i = 0; i < vCnt; i++) {
				let v1 = area.vertices[i],
					v2 = area.vertices[vCnt*2 - i - 1],
					wd = Math.abs(v1.x - v2.x);
				let y1 = start + cumuWds[i] * dir, y2 = start + (cumuWds[i] + wd) * dir;
				v1._doTranslate(0, y1 - v1.y);
				v2._doTranslate(0, y2 - v2.y);
				cumuWds[i] += wd;
			}
			area._updateBounds();
		}
		if (this._horzCellAlignment === Alignment.Center) {
			for (let area of areas) {
				for (let i = 0; i < vCnt; i++) {
					let v1 = area.vertices[i],
						v2 = area.vertices[vCnt*2 - i - 1];
					let l = gb.center - cumuWds[i]/2;
					v1._doTranslate(0, l - gb.left);
					v2._doTranslate(0, l - gb.left);
				}
				area._updateBounds();
			}
		}
		this.group._updateBounds();		
	}

	_stackAreas() {
		let area = this.group.children[0];
		if (area.orientation === Orientation.Horizontal) {
			this._stackAreasVert();
		} else {
			this._stackAreasHorz();
		}
	}

	_stackArcs() {
		let group = this.group;
		if (this._orientation === Orientation.Angular) {
			let startAngle = this.startAngle ? this.startAngle : 90,
				dir = this._direction ? this._direction : Direction.Clockwise;
			if (dir === Direction.Clockwise) {
				for (let c of group.children) {
					let temp = normalizeAngle(startAngle - c.angle);
					c.adjustAngle(temp, startAngle);
					startAngle = temp;
				}
			} else {
				for (let c of group.children) {
					let temp = normalizeAngle(startAngle + c.angle);
					c.adjustAngle(startAngle, temp);
					startAngle = temp;
				}
			}	
		}
	}

	_stackRects() {
		let scene = this.group.getScene();
		let group = this.group, o = this._orientation;
		let bounds = group.children.map(d => d.bounds);
		let lefts = bounds.map(d => d.left),
			tops = bounds.map(d => d.top),
			wds = bounds.map(d => d.width),
			hts = bounds.map(d => d.height);
		let left = this._left == undefined ? Math.min(...lefts) : this._left,
			top = this._top == undefined ? Math.min(...tops) : this._top;

		let maxWd = Math.max(...wds), maxHt = Math.max(...hts);
		if (o == Orientation.Vertical) {
			let centerX = left + maxWd/2;
			for (let i = 0; i < group.children.length; i++) {
				let c = group.children[i]; 
				let dx = centerX - c.bounds.x,
					dy = top + c.bounds.height/2 - c.bounds.y;
				top += c.bounds.height + this._gap;
				c._doTranslate(dx, dy);
				//alignment
				let cdx = 0, cdy = 0;
				let xEnc = scene.getEncodingByItem(c, "x");
				if (!xEnc) {
					switch (this._horzCellAlignment) {
						case Alignment.Left:
							cdx = left - c.bounds.left;
							break;
						case Alignment.Center:
							cdx = left + maxWd/2 - c.bounds.x;
							break;
						case Alignment.Right:
							cdx = left + maxWd - c.bounds.right;
							break;
					}
				}
				c._doTranslate(cdx, cdy);
			}
		} else {
			let centerY = top + maxHt/2;
			for (let i = 0; i < group.children.length; i++) {
				let c = group.children[i]; 
				let dx = left + c.bounds.width/2 - c.bounds.x,
					dy = centerY - c.bounds.y;
				left += c.bounds.width + this._gap;
				c._doTranslate(dx, dy);

				//TODO: alignment
				let cdx = 0, cdy = 0;
				let yEnc = scene.getEncodingByItem(c, "y");
				if (!yEnc) {
					switch (this._vertCellAlignment) {
						case Alignment.Top:
							cdy = top - c.bounds.top;
							break;
						case Alignment.Middle:
							cdy = top + maxHt/2 - c.bounds.y;
							break;
						case Alignment.Bottom:
							cdy = top + maxHt - c.bounds.bottom;
							break;
					}
				}
				c._doTranslate(cdx, cdy);
			}
		}
		this.group._updateBounds();	
	}

	run() {
		if (this.group == undefined || !this.group.children || this.group.children.length === 0)
			return;
		let leafMark = getLeafMarks(this.group)[0];
		switch (leafMark.type) {
			case ItemType.Area:
				this._stackAreas();
				break;
			case ItemType.Arc:
			case ItemType.Pie:
				if (leafMark.parent === this.group)
					this._stackArcs();
				break;
			case ItemType.Rect:
			case ItemType.Image:
			case ItemType.Circle:
				this._stackRects();
				break;
			default:
				break;
		}
	}

	set vertCellAlignment(v) {
		if (v != Alignment.Top && v != Alignment.Bottom && v != Alignment.Middle) {
			throw Errors.UNKOWN_ALIGNMENT;
		}
		this._vertCellAlignment = v;
		this.run();
	}

	get vertCellAlignment() {
		return this._vertCellAlignment;
	}

	set horzCellAlignment(h) {
		if (h != Alignment.Left && h != Alignment.Center && h != Alignment.Right) {
			throw Errors.UNKOWN_ALIGNMENT;
		}
		this._horzCellAlignment = h;
		this.run();
	}

	get horzCellAlignment() {
		return this._horzCellAlignment;
	}

	get cellBounds() {
		return this.group.children.map(d => d.bounds);
	}

	get orientation() {
		return this._orientation;
	}

	set orientation(o) {
		this._orientation = o;
		this.run();
	}
}